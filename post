#!/usr/bin/env python
import optparse
import sys
import os
import tempfile
import marshal
import urllib2

POST_VERSION = "1.0"

# Error codes
MISSING_RBTOOLS = 1
UNSUPPORTED_RBTOOLS = 2
UNSUPPORTED_OS = 3
UNSUPPORTED_PYTHON = 4
CONFIG_ERROR = 5
UNKNOWN_ACTION = 6
P4_EXCEPTION = 7
RB_EXCEPTION = 8

# Required Versions
PYTHON_VERSION = (2, 5)
PYTHON_VERSION_STR = '2.5'
RBTOOLS_VERSION = (0, 4, 0)
RBTOOLS_VERSION_STR = '0.4.0'
RBTOOLS_URL = 'http://www.reviewboard.org/docs/manual/1.7/users/tools/post-review/'
RBTOOLS_VERSION_MSG = """
Use of this script requires:

  RBTools version %s or greater
  Python %s or greater

For installation instructions, please see this page:

  %s

IMPORTANT:

If you're on a linux system with an older python, updating python
could break your package management system and is not advised.
If that's the case, please use

  /build/cm/bin/rb2

""" % (RBTOOLS_VERSION_STR, PYTHON_VERSION_STR, RBTOOLS_URL)
try:
    from rbtools import postreview
    from rbtools import VERSION
    from rbtools.clients import perforce
    import rbtools.api.errors
except ImportError:
    sys.stderr.write(RBTOOLS_VERSION_MSG)
    raise SystemExit(MISSING_RBTOOLS)
else:
    if rbtools.VERSION < RBTOOLS_VERSION:
        sys.stderr.write("\nERROR: Found old version of RBTools: Version %s\n" % rbtools.get_package_version())
        sys.stderr.write(RBTOOLS_VERSION_MSG)
        raise SystemExit(UNSUPPORTED_RBTOOLS)


class RBError(Exception): pass;


class P4Error(Exception): pass;


class P4:
    """
    Encapsulate perforce environment and handle calls to the perforce server.

    """

    def __init__(self):
        """
        Create an object to interact with perforce using the user, port and client
        settings from the environment.
        """
        p4info = self.info()
        self.user = p4info['userName']
        self.port = p4info['serverAddress']
        self.client = p4info['clientName']

    def info(self):
        p4info = self.run_G("info")
        if not p4info:
            raise P4Error("Could not talk to the perforce server.")
        return p4info[0]

    def run(self, cmd):
        """Run perforce cmd and return output as a list of output lines."""
        cmd = "p4 " + cmd
        child = os.popen(cmd)
        data = child.read().splitlines()
        err = child.close()
        if err:
            raise P4Error("Perforce command '%s' failed.\n" % cmd)
        return data

    def run_G(self, cmd, args=None, p4_input=0):
        """
        Run perforce command and marshal the IO. Returns stdout as a  dict.

        This code was copied from this perforce knowledge base page:

        http://kb.perforce.com/article/585/using-p4-g

        I modified it slightly for error checking.
        """

        c = "p4 -G " + cmd

        # All input to this method should be internal to this program, so
        # if we don't have either None or a list, something is very wrong.
        if not args is None:
            if isinstance(args, list):
                c = c + " " + " ".join(args)
            else:
                raise P4Error(
                    "Program Error: run_G unexpectedly received a non-list value for 'args'.\nPlease contact CM.")

        if sys.version_info < (2, 6):
            (pi, po) = os.popen2(c, "b")
        else:
            from subprocess import Popen, PIPE

            p = Popen(c, stdin=PIPE, stdout=PIPE, shell=True)
            (pi, po) = (p.stdin, p.stdout)

        if p4_input:
            marshal.dump(p4_input, pi, 0)
            pi.close()

        results = []
        try:
            while 1:
                x = marshal.load(po)
                results.append(x)
        except EOFError:
            pass
        po.close()

        # check for known perforce errors
        for r in results:
            if r['code'] == 'error':
                msg = "\n'%s' command failed.\n\n" % c
                msg += "%s\n" % r['data']
                raise P4Error(msg)
        return results

    def __str__(self):
        return "user: %s port: %s client: %s" % (self.user, self.port, self.client)

    def opened(self, change_number=None):
        """Return a dict with opened files for user."""
        if change_number:
            cmd = "opened -c %s" % change_number
        else:
            cmd = "opened"
        return self.run_G(cmd)

    def changes(self, status=None):
        """Return a dict with changes for user."""
        cmd = "changes -u %s" % self.user
        if status:
            cmd += " -s %s" % status
        return self.run_G(cmd)

    def changelist_owner(self, change_number):
        """Return the user name of the change list owner"""
        change_list = self.get_change(change_number)
        return change_list['User']

    def verify_owner(self, change_list):
        """Raise exception if we are not the owner of the change list."""
        change_owner = self.changelist_owner(change_list)
        if self.user != change_owner:
            raise P4Error(
                "Perforce change %s is owned by %s - you are running as %s." % (change_list, change_owner, self.user))

    def new_change(self):
        """
        Create a numbered change list with all files in the default change list.

        Run p4 change on the default change list to create a new, numbered change
        and return the new change list number.

        Raise exception if there are no files in the default changelist.

        """
        if len(self.opened("default")) == 0:
            raise P4Error("No files opened in default changelist.")

        # Capture a change template with files opened in the default change list
        change_template = self.run("change -o")

        # Create a temp file and dump the p4 change to it.
        change_form = tempfile.NamedTemporaryFile(mode="w", delete=False)
        for line in change_template:
            change_form.write(line + "\n")
        change_form.close()

        # Open the file in the users editor
        editor = self.get_editor()
        os.system("%s %s" % (editor, change_form.name))

        # Use 2.4 compatible version because we have so many CentOS 5 users
        f = None
        try:
            f = open(change_form.name, "r")
            new_change_form = [s.rstrip() for s in f.readlines()]
        except EnvironmentError, e:
            if os.path.isfile(change_form.name):
                os.remove(change_form.name)
            if f:
                f.close()
            raise RBError("Couldn't read the saved change list form.\n%s" % e)

        # The user may have changed their mind, so see if the file changed at all.
        if change_template == new_change_form:
            if os.path.isfile(change_form.name):
                os.remove(change_form.name)
            raise RBError("No changes made to change list.")
        else:
            # Use 2.4 compatible syntax since we have so many CentOS 5 users.
            try:
                try:
                    change_output = self.run("change -i < %s" % change_form.name)
                except P4Error, e:
                    # Give user a chance to fix the problem
                    print "Error in change specification:\n%s" % e
                    confirm = raw_input("Try again? n|[y]: ")
                    if confirm == '' or confirm.lower() == 'y':
                        os.system("%s %s" % (editor, change_form.name))
                        change_output = self.run("change -i < %s" % change_form.name)
                    else:
                        raise P4Error("Change specification errors not fixed.")
            finally:
                if os.path.isfile(change_form.name):
                    os.remove(change_form.name)
            return change_output[0].split()[1]

    def get_change(self, change_number):
        """Return dict with change_number change list"""
        return self.run_G("change -o %s" % change_number)[0]

    def edit_change(self, change_number):
        os.system("p4 change %s" % change_number)

    def shelve(self, change_number):
        """Create a p4 shelve from change_number"""
        cmd = "shelve -c %s" % change_number
        return self.run_G(cmd)

    def update_shelf(self, change_number):
        """Update the shelved change_number"""
        cmd = "shelve -r -c %s" % change_number
        return self.run_G(cmd)

    def shelved(self, change_number):
        """Return True if the change_number is a shelved change list"""
        return change_number in self.shelves()

    def shelves(self):
        """Return list of change list numbers for user that are currently shelved."""
        shelved_changes = self.changes("shelved")
        return [int(sc['change']) for sc in shelved_changes]

    def unshelve(self, change_number):
        """Delete the shelf for the change_number"""
        cmd = "shelve -d -c %s" % change_number
        output = self.run_G(cmd)
        return output

    def get_jobs(self, change_number):
        """Return list of jobs associated with this change list."""
        change = self.get_change(change_number)
        jobs = [change[k] for k in change.keys() if k.startswith('Jobs')]
        return jobs

    def submit(self, change_number):
        """Submit change and return submitted change number"""
        cmd = "submit -c %s" % change_number
        output = self.run_G(cmd)

        # Check each dict in the output until we find submittedChange
        submitted_change = None
        for line in output:
            if line.has_key("submittedChange"):
                submitted_change = int(line['submittedChange'])
                break
        if submitted_change is None:
            raise P4Error("Failed to determine submitted change list number.")
        return submitted_change

    def add_reviewboard_shipits(self, review, ship_its):
        """
        Add list of users who approved the review to the change list.

        """

        ship_it_line = "Reviewed by: %s" % (", ".join(ship_its))
        change = self.get_change(review.change_list)
        change_description = change['Description'].splitlines()

        # Look for a 'Reviewed by:' field in the description so we don't
        # end up with multiple entries.
        found = False
        for lineno in range(0, len(change_description)):
            if change_description[lineno].startswith("Reviewed by:"):
                change_description[lineno] = ship_it_line
                found = True
                break
        if not found:
            change_description.extend(['', ship_it_line])

        change['Description'] = "\n".join(change_description)
        self.run_G("change -i", p4_input=change)


    def set(self):
        """Return output of 'p4 set' as a dict."""
        set_list = self.run("set")
        set_dict = {}
        for item in set_list:
            k, v = item.split('=')
            set_dict[k] = v
        return set_dict

    def get_editor(self):
        """
        Return the editor to use based on environment variables.

        Look at various environment variables to see if the user has
        specified a favorite and return that value.

        Default: vi on linux and mac, notepad on windows

        """

        p4set = self.set()
        if p4set.has_key("P4EDITOR"):
            editor = p4set["P4EDITOR"]

            # If the editor is set in a p4.config file, the entry will end with (config)
            if editor.endswith(" (config)"):
                editor = editor[0:-9]
        elif os.environ.has_key("EDITOR"):
            editor = os.environ["EDITOR"]
        else:
            if os.name == "nt":
                editor = "notepad"
            else:
                editor = "vi"

        return editor


class F5Review:
    """
    Encapsulate a review request and handle interaction with Review Board server.
    """

    def __init__(self, server, change_list, review_id, bugs_closed=None):
        """
        Create an instance of F5Review.

        Fields:
        server -- an instance of postreview.ReviewBoardServer
        change_list -- the perforce change list number
        review_id  -- the review board id number
        bugs_closed -- list of bugs attached to the change_list

        We only need a server and change_list to instantiate the object.
        The review_id is obtained from the server via the change_list

        """

        self.server = server
        self.change_list = change_list
        self.review_id = review_id

        if bugs_closed is None:
            self.bugs_closed = []
        else:
            if not isinstance(bugs_closed, list):
                raise RBError(
                    "Program Error: unexpectedly received a non-list value for 'bugs_closed'.\nPlease contact CM.")
            self.bugs_closed = bugs_closed

        # Create a PerforceClient object to create proper diffs. This comes from rbtools.
        self.p4client = perforce.PerforceClient(options=options)
        self.p4client.get_repository_info()

        if options.debug:
            print self

    def __str__(self):
        return "Change:%s, RID: %s" % (self.change_list, self.review_id)

    @property
    def review_request(self):
        """
        Return the latest version of the review request and update id, changelist.

        We always get the latest version of the review from the server, we never store
        it in our object.
        """
        review_request = None
        try:
            if not self.review_id:
                if self.change_list:
                    self.review_id = get_review_id_from_changenum(self.server, self.change_list)
                else:
                    raise RBError("Review has no change list number and no ID number.")
            review_request = self.server.get_review_request(self.review_id)
            self.change_list = review_request['changenum']
        except rbtools.api.errors.APIError:
            raise RBError("Failed to retrieve review number %s." % self.review_id)
        return review_request

    def post_review(self):
        """Main method for creating and updating reviews on the Review Board Server."""

        # Pass the options we care about over to postreview.options
        postreview.options.target_people = options.target_people
        postreview.options.target_groups = options.target_groups
        postreview.options.server = options.server
        postreview.options.diff_only = options.diff_only
        postreview.options.change_only = options.change_only
        postreview.options.testing_done = options.testing_done
        postreview.options.testing_file = options.testing_file
        postreview.options.rid = options.rid
        postreview.options.debug = options.debug

        # I decided against supporting the username option. I think it's confusing
        # and there's rarely a need for it. On those occasions where it's
        # needed, we can run post-review.  Leaving the code in for now in
        # case I change my mind. Delete on 06/01/13 if still commented out.
        #
        # Turns out there's another reason I decided to not support it: I can't
        # get it to work quite right. When I hook it up, I get prompted for my
        # username even though I pass it.  That doesn't happen with post-review.
        # I don't kno why that happens but I don't want to spend a lot of time on it.
        # -sallan
        # postreview.options.username = options.username

        # Create our diff using rbtools
        diff, parent_diff = self.p4client.diff([self.change_list])

        if len(diff) == 0:
            raise RBError("There don't seem to be any diffs!")

        if options.output_diff_only:
            # The comma here isn't a typo, but rather suppresses the extra newline
            print diff,
            return

        # Post to review board server
        changenum = self.p4client.sanitize_changenum(self.change_list)
        self.server.login()
        review_url = postreview.tempt_fate(self.server, self.p4client, changenum, diff_content=diff,
                                           parent_diff_content=parent_diff,
                                           submit_as=options.submit_as)

        self.set_bugs_closed()
        if options.shelve:
            self.add_shelve_comment()

        # We publish here instead of letting post-review handle since we 
        # sometimes add stuff.
        if options.publish:
            self.publish()
        return review_url

    def add_shelve_comment(self):
        """Add comment to review regarding the shelved change list."""
        shelve_message = "This change has been shelved in changeset %s. " % self.change_list
        shelve_message += "To unshelve this change into your workspace:\n\n\tp4 unshelve -s %s" % self.change_list
        reviews_url = self.review_request['links']['reviews']['href']
        self.server.api_post(reviews_url, {
            'body_top': shelve_message,
            'public': 1
        })

    def submit(self, submitted_changelist):
        """Submit the change list to perforce and mark review as submitted."""
        review_id = self.review_id
        try:
            self.set_change_list(submitted_changelist)
            self.set_status("submitted")
            print "Change %s submitted." % submitted_changelist
            print "Review %s closed." % review_id
        except RBError, e:
            raise RBError("Failed to submit review.\n%s" % e)

    def get_ship_its(self):
        """Get unique list of reviewers who gave a ship it."""
        reviews = self.get_reviews()['reviews']
        ship_its = [str(self.get_reviewer_name(r)) for r in reviews if r['ship_it']]

        # Idiom for extracting unique elements from list
        return list(set(ship_its))

    def get_review_summary(self):
        return self.review_request['summary']

    def get_reviewer_name(self, review):
        """Returns First Last names for user who did given review."""
        user_id = review['links']['user']['title']
        user_url = self.server.url + "api/users/%s" % user_id
        user = self.server.api_get(user_url)
        return "%s %s" % (user['user']['first_name'], user['user']['last_name'])

    def set_bugs_closed(self):
        """Add list of bugs to the review request."""
        # We want to run this even if the bugs_closed list is empty.
        self.server.set_review_request_field(self.review_request, 'bugs_closed', ",".join(self.bugs_closed))

    def set_change_list(self, new_change):
        """Assign new change list number to review request."""

        # We can't use server.set_review_request_field here. I don't know why.
        # At any rate, this works.
        self.change_list = new_change
        self.server.api_put(self.review_request['links']['self']['href'], {
            'changenum': new_change,
        })

    def set_status(self, status):
        """Set the status for this review request."""

        # We can't use server.set_review_request_field here. I don't know why.
        # At any rate, this works.
        self.server.api_put(self.review_request['links']['self']['href'], {
            'status': status,
        })

    def get_reviews(self):
        """Return list of all reviews for this review request."""
        reviews_url = self.review_request['links']['reviews']['href']
        reviews = self.server.api_get(reviews_url)
        return reviews

    def save_draft(self):
        """Save current review draft."""
        self.server.save_draft(self.review_request)

    def publish(self):
        """Publish review."""
        self.server.publish(self.review_request)

    # The methods below are currently not used. But I may need them later
    # so I'm leaving them in for now.
    # TODO: Delete these if not used by 06/13.
    def get_review_draft(self):
        draft_url = self.review_request['links']['draft']['href']
        return self.server.api_get(draft_url)['draft']

    def add_change_description(self, description):
        self.server.set_review_request_field(self.review_request, 'changedescription', description)
        self.save_draft()

    def set_review_description(self, description, append=False):
        if append:
            description = self.review_request['description'] + "\n" + description
        self.server.set_review_request_field(self.review_request, "description", description)

# End of F5Review class


#==============================================================================
# Top-level functions
#==============================================================================
def migrate_rbrc_file(old_rc_file, new_rc_file):
    """
    Migrate any legacy .rbrc settings.

    Copy known compatible settings from the legacy .rbrc file to a new
    .reviewboardrc file. This function should only get called if there is
    not already an existing .reviewboardrc file.

    """

    # Use 2.4 compatible version because we have so many CentOS 5 users
    f = None
    try:
        try:
            f = open(old_rc_file, "r")
            old_rc = f.read().splitlines()
        except EnvironmentError, e:
            raise RBError("Can't read %s\n%s" % (old_rc_file, e))
    finally:
        if f:
            f.close()

    # We don't migrate the user name because doing so causes post-review
    # to prompt for a password each time. By leaving it out, you get prompted
    # once and then future requests use the cookies file.  In fact, the only
    # value we want to migrate is the server name and ssl setting.
    old_settings = {}
    for line in old_rc:
        k, v = [s.strip() for s in line.split("=")]
        old_settings[k] = v

    server_url = False
    if old_settings.has_key("server"):
        server_name = old_settings["server"]
        protocol = "http"
        if old_settings.has_key("use_ssl") and old_settings["use_ssl"] == "1":
            protocol = "https"
        server_url = protocol + "://" + server_name

    if server_url:
        # Use 2.4 compatible version because we have so many CentOS 5 users
        f = None
        try:
            try:
                f = open(new_rc_file, "w")
                f.write('REVIEWBOARD_URL = "%s"\n' % server_url)
            except EnvironmentError, e:
                raise RBError("Failed to write %s\n%s" % (new_rc_file, e))
        finally:
            if f:
                f.close()

        # Let the user know a new config file was created
        print "Wrote config file: %s" % new_rc_file


def check_config(user_home):
    """
    Reconcile old and new configuration files.

    Look for a legacy .rbrc file in the user home directory and then for a .reviewboardrc.
    If you find both, warn the user and use .reviewboardrc. If only .rbrc, migrate those
    settings to .reviewboardrc.

    """
    rbrc_file = os.path.join(user_home, ".rbrc")
    reviewboardrc_file = os.path.join(user_home, ".reviewboardrc")
    if os.path.isfile(rbrc_file) and not os.path.isfile(reviewboardrc_file):
        print "Found legacy %s file." % rbrc_file
        print "Migrating to %s" % reviewboardrc_file
        migrate_rbrc_file(rbrc_file, reviewboardrc_file)


def get_server(user_config, cookie_file):
    """
    Create an instance of a ReviewBoardServer with our configuration settings.

    The server returned by this function is used by the F5Review class to talk
    directly to the Review Board server.

    """
    perforce = postreview.PerforceClient(options=options)
    if options.server:
        # Users used to using rb are accustomed to providing the server without
        # the protocol string. In that case, assume https.
        if not options.server.startswith('http'):
            options.server = 'https://' + options.server
        server_url = options.server
    else:
        if user_config and user_config.has_key("REVIEWBOARD_URL"):
            server_url = user_config["REVIEWBOARD_URL"]
        else:
            raise RBError(
                "No server url found. Either set in your .reviewboardrc file or pass it with --server option.")

    repository_info = perforce.get_repository_info()
    try:
        server = postreview.ReviewBoardServer(server_url, repository_info, cookie_file)
        server.check_api_version()
    except urllib2.URLError, e:
        raise RBError(
            "Failed to connect to %s: %s\nPlease check the REVIEWBOARD_URL entry in $HOME/.reviewboardrc"
            % (server_url, e))
    return server


def get_review_id_from_changenum(server, changenum):
    """Return Review Board ID number for given changenum. Raises exception if not found."""
    url = "%sapi/review-requests?changenum=%s" % (server.url, changenum)
    no_review_message = """\
Cant' find an open review for change list: %s
Did you intend to create a new review? If not
please check your perforce settings and if the
problem persists contact CM.""" % changenum

    try:
        review = server.api_get(url)
        if review['review_requests']:
            review_id = review['review_requests'][0]['id']
        else:
            raise RBError(no_review_message)
    except rbtools.api.errors:
        raise RBError(no_review_message)
    return review_id


def get_option_parser():
    """Options parser and usage."""

    description = """
Create, update and submit review requests.

This script is a wrapper to the post-review script that comes with Review Board.
It can only be used with perforce and provides some additional functionality related
to perforce.  The work flow is create/edit/submit. Alternatively, the diff command will
print a Review Board compatible diff of a change list to STDOUT without creating or
modify a review.

The options for each command are described below.

"""

    parser = optparse.OptionParser(
        usage="%prog [OPTIONS] create|edit|submit|diff [changenum]",
        description=description
    )
    parser.add_option("-v", "--version",
                      default=False, dest="version", action="store_true",
                      help="Display version and exit.")
    parser.add_option("-d", "--debug",
                      dest="debug", action="store_true", default=False,
                      help="Display debug output.")
    parser.add_option("--server",
                      dest="server", metavar="<server_name>",
                      help="Use specified server. Default is the REVIEWBOARD_URL entry in .reviewboardrc file.")

    submit_group = optparse.OptionGroup(parser, "Submit Options")
    submit_group.add_option("-f", "--force",
                            dest="force", action="store_true", default=False,
                            help="Submit even if the review doesn't meet all requirements.")
    submit_group.add_option("-e", "--edit-changelist",
                            dest="edit", action="store_true", default=False,
                            help="Edit the change list before submitting.")

    edit_group = optparse.OptionGroup(parser, "Create and Edit Options")
    edit_group.add_option("-p", "--publish",
                          dest="publish", action="store_true", default=False,
                          help="Publish the review.")
    edit_group.add_option("-n", "--output-diff",
                          dest="output_diff_only", action="store_true", default=False,
                          help="Output diff to console and exit. Do not post.")
    edit_group.add_option("--target-groups",
                          dest="target_groups", metavar="<group [,groups]>",
                          help="Assign or replace ReviewBoard groups for this review.")
    edit_group.add_option("--target-people",
                          dest="target_people", metavar="<user [,users]>",
                          help="Assign or replace reviewers for this review.")

    edit_group.add_option("--shelve",
                          dest="shelve", action="store_true", default=False,
                          help="Create or update p4 shelve for the files in the review.")
    edit_group.add_option("--update-diff",
                          dest="diff_only", action="store_true", default=False,
                          help="Uploads a new diff, but does not update information from change list.")
    edit_group.add_option("--change-only",
                          dest="change_only", action="store_true", default=False,
                          help="Updates info from change list, but does not upload diff.")
    edit_group.add_option("--testing-done",
                          dest="testing_done", metavar="<string>",
                          help="Description of testing done.")
    edit_group.add_option("--testing-done-file",
                          dest="testing_file", metavar="<filename>",
                          help="Text file containing description of testing done.")
    edit_group.add_option("-r", "--rid",
                          dest="rid", metavar="<ID>",
                          help="Upload changes to specific review by ID. Use this if your change list is different from the one associated with ID.")

    # I decided against supporting the username option. I think it's confusing
    # and there's rarely a need for it. On those occasions where it's
    # needed, we can run post-review.  Leaving the code in for now in
    # case I change my mind. Delete on 06/01/13 if still commented out.
    # -sallan
    #    edit_group.add_option("--username",
    #        dest="username", metavar="<user>",
    #        help="Switch to this Review Board username. Useful if different from p4 username (e.g. mergeit). " +
    #            "The new login credentials will remain in effect until you use --username again.")

    parser.add_option_group(edit_group)
    parser.add_option_group(submit_group)
    return parser


def parse_options(parser):
    """Parse command line options, strip of legacy UI elements and return args, optiions and action."""
    options, args = parser.parse_args()

    if options.version:
        print_version()
        raise SystemExit(0)

    if len(args) == 0:
        parser.print_help()
        raise SystemExit(0)

    # The command needs to be the first argument.
    action = args[0]
    args = args[1:]

    if options.testing_done and options.testing_file:
        raise RBError("The --testing-done and --testing-done-file options "
                      "are mutually exclusive.\n")

    if options.testing_file:
        # Use 2.4 version since we have so many CentOS 5 users
        f = None
        try:
            try:
                f = open(options.testing_file, "r")
                options.testing_done = f.read()
            except EnvironmentError, e:
                raise RBError("Couldn't read test file '%s'\n%s" % (options.testing_file, e))
        finally:
            if f:
                f.close()

    # We expect these to be set in the environment. For that to work we
    # have to provide a value of None to these in the options namespace
    # because rbtools checks for it.
    options.p4_client = None
    options.p4_port = None

    # We don't support passing p4_passwd at all, so set it to None also.
    options.p4_passwd = None

    # This unsupported option also needs to be initialized
    options.submit_as = None

    return options, args, action


def create_review(change_list, server, p4):
    if change_list is None:
        change_list = p4.new_change()
    p4.verify_owner(change_list)

    # If user is asking to create a review with a change already 
    # associated with a review, don't allow it.
    review_id = None
    try:
        review_id = get_review_id_from_changenum(server, change_list)
    except:
        #  Good, we didn't find a review for this change list
        pass
    if review_id:
        raise RBError("Change list %s already associated with review %s.\nDid you intend to 'edit' the review?" % (
        change_list, review_id))

    if options.shelve:
        print "Shelving files for change %s." % change_list
        p4.shelve(change_list)

    bugs_closed = p4.get_jobs(change_list)
    review = F5Review(server, change_list, review_id, bugs_closed)

    review.post_review()
    if not options.output_diff_only:
        print "Changelist: %s" % review.change_list
        if not options.publish:
            print "Don't forget to publish your review."


def edit_review(change_list, server, p4):
    if change_list is None:
        raise RBError("Need a change list number for this review")

    p4.verify_owner(change_list)

    # If the user passed an rid, use it, otherwise try to get it via the CL.
    if options.rid:
        review_id = options.rid
    else:
        review_id = get_review_id_from_changenum(server, change_list)

    bugs_closed = p4.get_jobs(change_list)
    review = F5Review(server, change_list, review_id, bugs_closed)

    review.post_review()
    if not options.output_diff_only:
        print "Changelist: %s" % review.change_list
        if not options.publish:
            print "Don't forget to publish your review."


def submit_review(change_list, server, p4):
    if change_list is None:
        raise RBError("Need a change list number for this review")
    p4.verify_owner(change_list)

    review_id = get_review_id_from_changenum(server, change_list)
    bugs_closed = p4.get_jobs(change_list)
    review = F5Review(server, change_list, review_id, bugs_closed)

    if not review.get_ship_its() and not options.force:
        raise RBError("Review %s has no 'Ship It' reviews. Use --force to submit anyway." % review.review_id)

    if p4.shelved(review.change_list):
        if options.force:
            print "Deleting shelve since --force option used."
            p4.unshelve(review.change_list)
        else:
            msg = "Cannot submit a shelved change (%s).\n" % review.change_list
            msg += "You may use --force to delete the shelved change automatically prior to submit."
            raise RBError(msg)

    if options.edit:
        p4.edit_change(review.change_list)

    ship_its = review.get_ship_its()
    if ship_its:
        p4.add_reviewboard_shipits(review, ship_its)
    submitted_change_list = p4.submit(review.change_list)
    review.submit(submitted_change_list)


def diff_changes(options, change_list):
    if change_list is None:
        change_list = "default"

    perforce = postreview.PerforceClient(options=options)
    perforce.get_repository_info()
    diff, parent_diff = perforce.diff([change_list])
    if len(diff) == 0:
        raise RBError("There don't seem to be any diffs!")
    print diff,


def print_version():
    program_name = os.path.basename(sys.argv[0])
    print "%s %s (using RBTools %s)" % (program_name, POST_VERSION, rbtools.get_package_version())


def main():
    # For now, we don't run on Windows
    if os.name == "nt":
        sys.stderr.write("This script is currently not supported on Windows.\n")
        sys.stderr.write("Please use post-review instead.\n")
        raise SystemExit(UNSUPPORTED_OS)

    # Check Python version
    if sys.version_info < PYTHON_VERSION:
        sys.stderr.write("This script requires Python version %s or greater.\n" % PYTHON_VERSION_STR)
        sys.stderr.write("Please use the rb2 script instead.\n")
        raise SystemExit(UNSUPPORTED_PYTHON)

    # Configuration and options
    global options
    global configs
    user_home = os.path.expanduser("~")

    # Check for a legacy .rbrc file and migrate it to .reviewboardrc if necessary
    try:
        check_config(user_home)
    except RBError, e:
        print e
        raise SystemExit(CONFIG_ERROR)

    user_config, configs = postreview.load_config_files(user_home)
    parser = get_option_parser()

    # We need to call our option parser and then also call postreview's parse_options
    # because it sets global variables that we need for our operations.
    # We don't care about the return value of postreview's parse_options.
    options, args, action = parse_options(parser)
    postreview.parse_options(args)

    if options.version:
        print "Version is ", VERSION
        raise SystemExit(0)

    actions = {
        "create": lambda: create_review(change_list, server, p4),
        "edit": lambda: edit_review(change_list, server, p4),
        "submit": lambda: submit_review(change_list, server, p4),
        "diff": lambda: diff_changes(options, change_list),
    }

    if not actions.has_key(action):
        print "Unknown action: %s. Try -h for usage." % action
        raise SystemExit(UNKNOWN_ACTION)

    change_list = None
    if args:
        change_list = args[0]
    try:
        if action == "diff":
            actions[action]()
        else:
            p4 = P4()
            rb_cookies_file = os.path.join(user_home, ".post-review-cookies.txt")
            server = get_server(user_config, rb_cookies_file)
            actions[action]()
    except P4Error, e:
        print e
        raise SystemExit(P4_EXCEPTION)
    except RBError, e:
        print e
        raise SystemExit(RB_EXCEPTION)


if __name__ == "__main__":
    main()

# EOF
