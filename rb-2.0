#!/usr/bin/perl -w

# Command line interface for Google's reviewboard server.
# Copyright (C) 2008 F5 Networks, Inc.
#
# This script is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as
# published by the Free Software Foundation.

use strict 'refs';
use warnings;
use Data::Dumper;

use Getopt::Long;
use IPC::Open2;
use HTTP::Cookies;
use HTTP::Request;
use HTTP::Request::Common;
use HTTP::Response;
use LWP::UserAgent;
use Term::ANSIColor;

# Globals
my $home = $ENV{'HOME'};
my %prefs;

my %prefs_default = (
    'use_ssl'             => 1,
    'server'              => "reviewboard",
    'cookiefile'          => "$home/.rbcookies.txt",
    'use_color'           => 0,
    'timeout'             => 180,
    'color_indent1'       => 'green',
    'color_indent2'       => 'dark green',
    'color_indent3'       => 'dark green',
    'color_diff_file_old' => 'bold red',
    'color_diff_file_new' => 'bold green',
    'color_diff_hunk'     => 'magenta',
    'color_diff_context'  => 'reset',
    'color_diff_line_del' => 'red',
    'color_diff_line_add' => 'green'
);

my %custom_error_messages = (
    103 => "
############################################################
#
# ERROR: You are not logged in to reviewboard
#
# Please log in using your OLYMPUS credentials with this command:
# $0 login
#
############################################################

",
);

# Newer versions of LWP::UserAgent are stricter about checking ssl
# certificates, and ours fails. To get around this we use the new
# option to turn off hostname verification, but only on the newer
# versions.
my $ua;
if ( new_lwp($LWP::UserAgent::VERSION) ) {
    $ua = LWP::UserAgent->new( ssl_opts => { verify_hostname => 0 } );
}
else {
    $ua = LWP::UserAgent->new();
}

sub new_lwp {
    my $lwp_version = shift;
    return 0 unless $lwp_version;

# Every version of LWP I've seen begins with a digit. So any version that doesn't
# start with a digit we'll treat as old. Easy enough to fix later if this causes
# problems. Given that, we'll just pull off the leading digit and compare it to
# the version we consider new.
    my $is_new = 0;
    if ( $lwp_version =~ /^(\d+)/ ) {
        $is_new = ( $1 >= 6 );
    }
    return $is_new;
}

my $verbose_level = 1;

sub verbose($ $) {
    print STDERR $_[1] if ( $verbose_level >= $_[0] );
}

sub stripws {
    foreach (@_) {
        s/^\s+//;
        s/\s+$//;
    }
}

sub is_numeric($) {
    my $val = shift;
    if ( $val =~ /^-?\d+(\.\d+)?$/ ) {
        return 1;
    }
    return 0;
}

sub string_to_bool($) {
    my $val = shift;
    if ( $val =~ /^yes$/i || $val =~ /^true/i ) {
        return 1;
    }
    if ( $val =~ /^no$/i || $val =~ /^false/i ) {
        return 0;
    }
    if ( is_numeric($val) ) {
        return ( $val == 0 ? 0 : 1 );
    }
    warn("to_bool: assume false for $val\n");
    return 0;
}

sub bool_to_yn($) {
    my $val = shift;
    return ( $val ? 'Yes' : 'No' );
}

sub bool_to_tf($) {
    my $val = shift;
    return ( $val ? 'True' : 'False' );
}

sub prompt_y_or_n($ $) {
    my ( $query, $default ) = @_;
    if ( $default eq 'y' ) {
        $query = "$query n|[y]: ";
    }
    else {
        $query = "$query y|[n]: ";
    }
    print $query;
    my $response = <STDIN>;
    chomp $response;
    $response ||= $default;
    return lc $response eq 'y';
}

sub http_transaction($) {
    my $request = shift;
    verbose( 4, ">>>\n" . $request->as_string() . ">>>\n" );
    my $response = $ua->request($request);
    verbose( 4, "<<<\n" . $response->as_string() . "<<<\n" );
    return $response;
}

my $prefs_file = "$home/.rbrc";

sub prefs_load() {
    if ( open( FH, "<$prefs_file" ) ) {
        my $line;
        my ( $key, $val );
        while ( $line = <FH> ) {
            chomp($line);
            next if ( $line =~ /^\s*$/ || $line =~ /^\s*#/ );
            ( $key, $val ) = split( /=/, $line, 2 );
            stripws($key);
            stripws($val);
            $prefs{$key} = $val;
        }
        close(FH);
    }
    foreach $key ( keys %prefs_default ) {
        if ( !defined( $prefs{$key} ) ) {
            $prefs{$key} = $prefs_default{$key};
        }
    }
}

sub prefs_save() {
    open( FH, ">$prefs_file" ) or return;
    my $key;
    foreach $key ( sort keys %prefs ) {
        print FH "$key=$prefs{$key}\n";
    }
    close(FH);
}

###
### JSON
###

my $json_indent_step = 2;

sub json_encode_scalar(\$);
sub json_encode_array($ \@);
sub json_encode_hash($ \%);

sub json_encode_scalar(\$) {
    my $v = $_[0];
    if ( $$v eq 'true' || $$v eq 'false' || $$v eq 'null' ) {
        return $$v;
    }
    if ( $$v =~ /^(-)?[0-9]+$/ ) {
        return $$v;
    }
    my $enc;
    my $n;
    my %json_escape_ctrl
        = ( "\b" => 'b', "\f" => 'f', "\n" => 'n', "\r" => 'r', "\t" => 't' );
    $enc .= "\"";
    for ( $n = 0; $n < length($$v); ++$n ) {
        my $c = substr( $$v, $n, 1 );
        if ( $c eq '\\' || $c eq '"' || $c eq '/' ) {
            $enc .= "\\$c";
        }
        elsif ( defined( $json_escape_ctrl{$c} ) ) {
            $enc .= "\\" . $json_escape_ctrl{$c};
        }
        else {
            $enc .= $c;
        }
    }
    $enc .= "\"";
    return $enc;
}

sub json_encode_array($ \@) {
    my $indent    = $_[0];
    my $data      = $_[1];
    my $datacount = scalar( @{$data} );
    my $enc;

    my $n = 0;
    while ( $n < $datacount ) {
        $enc .= " " x $indent;
        my $v = $data->[$n];
        my $r = ref($v);
        if ( $r eq '' ) {
            $v = \$data->[$n];
            $r = ref($v);
        }
        if ( $r eq 'SCALAR' ) {
            $enc .= json_encode_scalar($$v);
        }
        elsif ( $r eq 'ARRAY' ) {
            $enc .= "[\n";
            $enc .= json_encode_array( $indent + $json_indent_step, @$v );
        }
        elsif ( $r eq 'HASH' ) {
            $enc .= "{\n";
            $enc .= json_encode_hash( $indent + $json_indent_step, %$v );
        }
        else {
            die("json_encode: cannot encode type=$r\n");
        }
        ++$n;
        if ( $n < $datacount ) {
            $enc .= ",";
        }
        $enc .= "\n";
    }
    $indent -= $json_indent_step;
    $enc .= " " x $indent . "]";
    return $enc;
}

sub json_encode_hash($ \%) {
    my $indent    = $_[0];
    my $data      = $_[1];
    my $datacount = scalar( keys %{$data} );
    my $enc;

    my $n = 0;
    foreach my $key ( keys %$data ) {
        $enc .= " " x $indent;
        $enc .= "\"$key\" : ";
        my $v = $data->{$key};
        my $r = ref($v);
        if ( $r eq '' ) {
            $v = \$data->{$key};
            $r = ref($v);
        }
        if ( $r eq 'SCALAR' ) {
            $enc .= json_encode_scalar($$v);
        }
        elsif ( $r eq 'ARRAY' ) {
            $enc .= "[\n";
            $enc .= json_encode_array( $indent + $json_indent_step, @$v );
        }
        elsif ( $r eq 'HASH' ) {
            $enc .= "{\n";
            $enc .= json_encode_hash( $indent + $json_indent_step, %$v );
        }
        else {
            die("json_encode: cannot encode type=$r\n");
        }
        ++$n;
        if ( $n < $datacount ) {
            $enc .= ",";
        }
        $enc .= "\n";
    }
    $indent -= $json_indent_step;
    $enc .= " " x $indent . "}";
    return $enc;
}

sub json_encode(\%) {
    my $enc;
    $enc = "{\n";
    $enc .= json_encode_hash( $json_indent_step, %{ $_[0] } );
    $enc .= "\n";
    return $enc;
}

sub json_next_token(\$ \$) {
    my $enc    = $_[0];
    my $pos    = $_[1];
    my $enclen = length($$enc);

    while ( $$pos < $enclen && substr( $$enc, $$pos, 1 ) =~ /\s/ ) {
        ++$$pos;
    }
    if ( $$pos >= $enclen ) {
        warn("json_next_token: EOI\n");
        return '';
    }

    my $json_toks     = "{}:[],";
    my $json_numbegin = "-0123456789";
    my $json_numbody  = "0123456789.Ee";
    my %json_escape_ctrl
        = ( 'b' => "\b", 'f' => "\f", 'n' => "\n", 'r' => "\r", 't' => "\t" );

    my $tok = substr( $$enc, $$pos++, 1 );
    if ( index( $json_toks, $tok ) < 0 ) {
        if ( index( $json_numbegin, $tok ) >= 0 ) {
            while ( index( $json_numbody, substr( $$enc, $$pos, 1 ) ) >= 0 ) {
                $tok .= substr( $$enc, $$pos++, 1 );
            }
        }
        elsif ( $tok eq '"' ) {
            $tok = '';
            my $c;
            while ( ( $c = substr( $$enc, $$pos, 1 ) ) ne '"' ) {
                if ( $c eq '\\' ) {
                    ++$$pos;
                    $c = substr( $$enc, $$pos, 1 );
                    if ( $c eq '"' || $c eq '\\' || $c eq '/' ) {

                        # no-op
                    }
                    elsif ( defined( $json_escape_ctrl{$c} ) ) {
                        $c = $json_escape_ctrl{$c};
                    }
                    elsif ( $c eq 'u' ) {
                        my $h4 = substr( $$enc, $$pos + 1, 4 );
                        if ( $h4 !~ /[[:xdigit:]]{4}/i ) {
                            warn(
                                "json_next_token: unknown sequence \\u$h4\n");
                            $h4 = "003f";    # '?'
                        }
                        $c = chr( hex("0x$h4") );
                        $$pos += 4;
                    }
                    else {
                        warn("json_next_token: unknown sequence \\$c\n");
                    }
                }
                $tok .= $c;
                ++$$pos;
            }
            ++$$pos;
        }
        else {
            while ( $$pos < $enclen && substr( $$enc, $$pos, 1 ) =~ /\w/ ) {
                $tok .= substr( $$enc, $$pos++, 1 );
            }
            if ( $tok ne 'true' && $tok ne 'false' && $tok ne 'null' ) {
                warn("json_next_token: unknown token $tok\n");
            }
        }
    }
    verbose( 4, "json_next_token: tok=$tok\n" );
    return $tok;
}

sub json_decode_array(\$ \$);
sub json_decode_hash(\$ \$);

sub json_decode_array(\$ \$) {
    my $enc = $_[0];
    my $pos = $_[1];
    my $tok;
    my @data;

    $tok = json_next_token( $$enc, $$pos );
    while ( $tok ne ']' ) {
        if ( $tok eq '[' ) {
            my @a = json_decode_array( $$enc, $$pos );
            push( @data, \@a );
        }
        elsif ( $tok eq '{' ) {
            my %h = json_decode_hash( $$enc, $$pos );
            push( @data, \%h );
        }
        else {
            push( @data, $tok );
        }
        $tok = json_next_token( $$enc, $$pos );
        if ( $tok ne ',' && $tok ne ']' ) {
            die("json_decode_array: expected comma or close bracket\n");
        }
        if ( $tok eq ',' ) {
            $tok = json_next_token( $$enc, $$pos );
        }
    }
    return @data;
}

sub json_decode_hash(\$ \$) {
    my $enc = $_[0];
    my $pos = $_[1];
    my $tok;
    my %data;

    $tok = json_next_token( $$enc, $$pos );
    while ( $tok ne '}' ) {
        my $key = $tok;
        $tok = json_next_token( $$enc, $$pos );
        if ( $tok ne ':' ) {
            die("json_decode_hash: expected colon\n");
        }
        $tok = json_next_token( $$enc, $$pos );
        if ( $tok eq '[' ) {
            my @a = json_decode_array( $$enc, $$pos );
            $data{$key} = \@a;
        }
        elsif ( $tok eq '{' ) {
            my %h = json_decode_hash( $$enc, $$pos );
            $data{$key} = \%h;
        }
        else {
            $data{$key} = $tok;
        }
        $tok = json_next_token( $$enc, $$pos );
        if ( $tok ne ',' && $tok ne '}' ) {
            die("json_decode_hash: expected comma or close brace\n");
        }
        if ( $tok eq ',' ) {
            $tok = json_next_token( $$enc, $$pos );
        }
    }
    return %data;
}

sub json_decode(\$) {
    my $enc = $_[0];
    my $pos = 0;
    my %data;
    my $tok;
    $tok = json_next_token( $$enc, $pos );
    if ( $tok ne '{' ) {
        die("json_decode: expected open brace\n");
    }
    %data = json_decode_hash( $$enc, $pos );
    return %data;
}

# End JSON

###
### rb
###

sub rb_uri($) {
    my $path = shift;

    if ( $prefs{'use_ssl'} && !$ua->is_protocol_supported('https') ) {
        my $sandbox_identity_file = '/var/lib/host-class/identity';
        my $perl_ssl_pkg
            = 'http://dag.wieers.com/rpm/packages/perl-Crypt-SSLeay/perl-Crypt-SSLeay-0.56-1.el3.rf.i386.rpm';
        my $perl_ssl_pkg_localpath
            = "/tmp/perl-Crypt-SSLeay-0.56-1.el3.rf.i386.rpm";
        my $sandbox_name = '';
        if ( -f $sandbox_identity_file ) {
            open( FH, "<$sandbox_identity_file" );
            $sandbox_name = <FH>;
            chomp($sandbox_name);
            close(FH);
        }
        if ( $prefs{'use_ssl'} && $sandbox_name eq 'bering' ) {
            die(      "Perl SSL support missing from bering sandbox\n"
                    . "Please install $perl_ssl_pkg\n" );
        }
        else {
            die(      "LWP::UserAgent does not support https\n"
                    . "Perhaps you need to install perl-Crypt-SSLeay or your distro equivalent?\n"
            );
        }
    }

    my $uri = ( $prefs{'use_ssl'} ? "https://" : "http://" );
    $uri .= $prefs{'server'};
    $uri .= "/$path";

    return $uri;
}

sub rb_exec_request($) {
    my $request = shift;

    # TODO: this needs to be handled properly.
    $request->authorization_basic( 'sallan', 'sallan' );
    print Dumper($request);

    my $response = http_transaction($request);
    if ( !$response->is_success() ) {
        my $errcode = $response->code();
        my $errmsg  = $response->message();
        die("Error: server returned error $errcode ($errmsg)\n");
    }
    my $dc   = $response->content();
    my %data = json_decode($dc);
    if ( !defined( $data{'stat'} ) ) {
        die("Error: no stat returned from request\n");
    }
    if ( $data{'stat'} ne 'ok' ) {

        my $msg
            = "Error: server request failed...\n"
            . "\turi="
            . $request->uri() . "\n"
            . "\tstat="
            . $data{'stat'} . "\n"
            . "\tcode="
            . $data{'err'}{'code'} . "\n"
            . "\tmsg="
            . $data{'err'}{'msg'} . "\n"
            . "Full server response:\n"
            . json_encode(%data);

        if ( exists( $custom_error_messages{ $data{err}->{code} } ) ) {
            $msg .= "\n" . $custom_error_messages{ $data{err}->{code} };
        }

        die($msg);
    }
    verbose( 3,
              ">>>\n"
            . $request->method() . " "
            . $request->uri() . "\n" . ">>>\n" . "<<<\n"
            . json_encode(%data)
            . "<<<\n" );
    return %data;
}

sub rb_login($) {

    # Disable this function
    return;
    my $password = shift;

    my $uri     = rb_uri("api/json/accounts/login/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [
            'username' => $prefs{'username'},
            'password' => $password
        ]
    );

    return rb_exec_request($request);
}

# sub rb_repositories() {
#     my $uri     = rb_uri("api/repositories/");
#     my $request = HTTP::Request::Common::GET($uri);
#     return rb_exec_request($request);
# }

# sub rb_users($) {
#     my $query = shift;

#     my $uri = rb_uri("api/json/users/");
#     if ( defined($query) && $query ne '' ) {
#         $uri .= "?query=$query";
#     }
#     my $request = HTTP::Request::Common::GET($uri);
#     return rb_exec_request($request);
# }

# sub rb_groups($) {
#     my $query = shift;

#     my $uri = rb_uri("api/json/groups/");
#     if ( defined($query) && $query ne '' ) {
#         $uri .= "?query=$query";
#     }
#     my $request = HTTP::Request::Common::GET($uri);
#     return rb_exec_request($request);
# }

# sub rb_group_star($ $) {
#     my $group = shift;
#     my $star  = shift;

#     my $uri = rb_uri("api/json/groups/$group/");
#     if ($star) {
#         $uri .= "star/";
#     }
#     else {
#         $uri .= "unstar/";
#     }
#     my $request = HTTP::Request::Common::POST(
#         $uri,
#         Content_Type => 'form-data',
#         Content      => []
#     );
#     return rb_exec_request($request);
# }

sub rb_review_request_create {
    my ( $repo, $cset, $alias ) = @_;
    my $uri     = rb_uri("api/review-requests/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [
            'repository' => $repo,
            'changenum'  => $cset,
        ]
    );
    return rb_exec_request($request);
}

sub rb_review_request_get($) {
    my $rid = shift;

    my $uri     = rb_uri("api/review-requests/$rid/");
    my $request = HTTP::Request::Common::GET($uri);
    return rb_exec_request($request);
}

# sub rb_review_request_get_all($) {
#     my $status = shift;

#     my $uri     = rb_uri("api/json/reviewrequests/all/?status=$status");
#     my $request = HTTP::Request::Common::GET($uri);
#     return rb_exec_request($request);
# }

# sub rb_review_request_get_to_group($ $) {
#     my $name   = shift;
#     my $status = shift;

#     my $uri
#         = rb_uri("api/json/reviewrequests/to/group/$name/?status=$status");
#     my $request = HTTP::Request::Common::GET($uri);
#     return rb_exec_request($request);
# }

# sub rb_review_request_get_to_user($ $) {
#     my $name   = shift;
#     my $status = shift;

#     my $uri = rb_uri("api/json/reviewrequests/to/user/$name/?status=$status");
#     my $request = HTTP::Request::Common::GET($uri);
#     return rb_exec_request($request);
# }

# sub rb_review_request_get_from_user($ $) {
#     my $name   = shift;
#     my $status = shift;

#     my $uri
#         = rb_uri("api/json/reviewrequests/from/user/$name/?status=$status");
#     my $request = HTTP::Request::Common::GET($uri);
#     return rb_exec_request($request);
# }

# sub rb_review_request_update($) {
#     my $rid = shift;

#     my $uri = rb_uri("api/json/reviewrequests/$rid/update_from_changenum/");
#     my $request = HTTP::Request::Common::POST(
#         $uri,
#         Content_Type => 'form-data',
#         Content      => []
#     );
#     return rb_exec_request($request);
# }

# sub rb_review_request_publish {
#     my $rid = shift;

#     my $uri     = rb_uri("api/review-requests/$rid/drafts/");
#     my $request = HTTP::Request::Common::POST(
#         $uri,
#         Content_Type => 'form-data',
#         Content      => [ public => 1 ]
#     );

#     # TODO: auth is a mess.
#     $request->authorization_basic( 'sallan', 'sallan' );
#     return rb_exec_request($request);
# }

sub rb_review_request_add_shelve_comment {
    my ( $rid, $cset_id ) = @_;
    my $comment
        = "This change has been shelved in changeset $cset_id.\n"
        . "To unshelve this change into your workspace:\n\n"
        . "        p4 unshelve -s $cset_id\n";

    rb_review_request_draft_set_field( $rid, "changedescription", $comment );
    rb_review_request_draft_save($rid);
}

sub rb_review_request_set_changelist {
    my ( $rid, $changelist ) = @_;
    my $uri     = rb_uri("api/review-requests/$rid/");
    my $request = HTTP::Request::Common::PUT( $uri,
        Content => "changenum=$changelist" );
    return rb_exec_request($request);
}

sub rb_review_request_set_status {
    my ( $rid, $status ) = @_;
    my $uri = rb_uri("api/review-requests/$rid/");
    my $request
        = HTTP::Request::Common::PUT( $uri, Content => "status=$status" );
    return rb_exec_request($request);
}

sub rb_review_request_draft_set_field {
    my ( $rid, $key, $val ) = @_;
    my $uri     = rb_uri("api/review-requests/$rid/draft/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [ $key => $val ]
    );
    return rb_exec_request($request);
}

sub rb_review_request_draft_save {
    my $rid = shift;

    my $uri     = rb_uri("api/review-requests/$rid/draft/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [ public => 1 ]
    );
    return rb_exec_request($request);
}

sub rb_review_request_review_get_all {
    my $rid     = shift;
    my $uri     = rb_uri("api/review-requests/$rid/reviews/");
    my $request = HTTP::Request::Common::GET($uri);
    return rb_exec_request($request);
}

sub rb_review_request_review_get_ship_its {
    my $rid         = shift;
    my %review_data = rb_review_request_review_get_all($rid);
    my @reviews     = @{ $review_data{'reviews'} };
    my @reviewers;
    my %reviewers;
    for my $review (@reviews) {
        if ( $review->{'ship_it'} eq 'true' ) {
            $reviewers{ $review->{'user'}{'fullname'} } = 1;
        }
    }
    return keys(%reviewers);
}

# # Calls json.py@review_draft_save() with publish=False.
# sub rb_review_request_review_draft_save {
#     my $rid         = shift;
#     my $shipit      = shift;
#     my $body_top    = shift;
#     my $body_bottom = shift;

#     # XXX: "shipit" key is always true if present in the POST:
#     #
#     #      review.ship_it     = request.POST.has_key('shipit')
#     #
#     # It would be ideal if we could use a %hash for Content, but that
#     # seems to be broken in Perl 5.8.0 (EL3).  I should try harder to
#     # make that work.
#     my $uri = rb_uri("api/review-requests/$rid/draft/");
#     my $request;
#     if ($shipit) {
#         $request = HTTP::Request::Common::POST(
#             $uri,
#             Content_Type => 'form-data',
#             Content      => [
#                 'body_top'    => $body_top,
#                 'body_bottom' => $body_bottom,
#                 'shipit'      => 1
#             ]
#         );
#     }
#     else {
#         print "HERE!!!\n";
#         $request = HTTP::Request::Common::POST( $uri,
#             Content => [ 'public' => 0 ] );
#     }
#     return rb_exec_request($request);
# }

# # Calls json.py@review_draft_save() with publish=True.
# sub rb_review_request_review_draft_publish($ $ $ $) {
#     my $rid         = shift;
#     my $shipit      = shift;
#     my $body_top    = shift;
#     my $body_bottom = shift;

#     # XXX: See comments in _save() above.
#     my $uri = rb_uri("api/json/reviewrequests/$rid/reviews/draft/publish/");
#     my $request;
#     if ($shipit) {
#         $request = HTTP::Request::Common::POST(
#             $uri,
#             Content_Type => 'form-data',
#             Content      => [
#                 'body_top'    => $body_top,
#                 'body_bottom' => $body_bottom,
#                 'shipit'      => 1
#             ]
#         );
#     }
#     else {
#         $request = HTTP::Request::Common::POST(
#             $uri,
#             Content_Type => 'form-data',
#             Content      => [
#                 'body_top'    => $body_top,
#                 'body_bottom' => $body_bottom
#             ]
#         );
#     }
#     return rb_exec_request($request);
# }

# # Calls json.py@review_draft_delete().
# # Kinda useless without _save.
# sub rb_review_request_review_draft_delete($) {
#     my $rid = shift;

#     my $uri = rb_uri("api/json/reviewrequests/$rid/reviews/draft/delete/");
#     my $request = HTTP::Request::Common::POST(
#         $uri,
#         Content_Type => 'form-data',
#         Content      => []
#     );
#     return rb_exec_request($request);
# }

# sub rb_review_request_review_draft_get_comments($) {
#     my $rid = shift;

#     my $uri = rb_uri("api/json/reviewrequests/$rid/reviews/draft/comments/");
#     my $request = HTTP::Request::Common::POST(
#         $uri,
#         Content_Type => 'form-data',
#         Content      => []
#     );
#     return rb_exec_request($request);
# }

# #XXX: need a rb_exec_request() that accepts 404 response...
# sub rb_review_request_review_reply_get_all($ $) {
#     my $rid      = shift;
#     my $reviewid = shift;

#     my $uri
#         = rb_uri("api/json/reviewrequests/$rid/reviews/$reviewid/replies/");

#     #    my $request = HTTP::Request::Common::POST($uri,
#     #                    Content_Type => 'form-data',
#     #                    Content => []);
#     my $request  = HTTP::Request::Common::GET($uri);
#     my $response = http_transaction($request);
#     my %data;
#     if ( $response->is_success() ) {
#         my $dc = $response->content();
#         %data = json_decode($dc);
#         if ( !defined( $data{'stat'} ) ) {
#             die("Error: no stat returned from request\n");
#         }
#         if ( $data{'stat'} ne 'ok' ) {
#             die(      "Error: server request failed...\n"
#                     . "\turi="
#                     . $request->uri() . "\n"
#                     . "\tstat="
#                     . $data{'stat'} . "\n"
#                     . "\tcode="
#                     . $data{'err'}{'code'} . "\n"
#                     . "\tmsg="
#                     . $data{'err'}{'msg'}
#                     . "\n" );
#         }
#         verbose( 3,
#                   ">>>\n"
#                 . $request->method() . " "
#                 . $request->uri() . "\n" . ">>>\n" . "<<<\n"
#                 . json_encode(%data)
#                 . "<<<\n" );
#     }
#     else {
#         my @a = ();
#         $data{'replies'} = \@a;
#     }
#     return %data;

#     #return rb_exec_request($request);
# }

# sub rb_review_request_review_reply_draft_set($ $ $ $) {
#     my $rid      = shift;
#     my $reviewid = shift;
#     my $context  = shift; # comment, screenshot_comment, body_top, body_bottom
#     my $value    = shift;

#     my $uri = rb_uri(
#         "api/json/reviewrequests/$rid/reviews/$reviewid/replies/draft/");
#     my $request = HTTP::Request::Common::POST(
#         $uri,
#         Content_Type => 'form-data',
#         Content      => [
#             'type'  => $context,
#             'value' => $value
#         ]
#     );
#     return rb_exec_request($request);
# }

# sub rb_review_request_review_reply_draft_publish($ $) {
#     my $rid      = shift;
#     my $reviewid = shift;

#     my $uri = rb_uri(
#         "api/json/reviewrequests/$rid/reviews/$reviewid/replies/draft/save/");
#     my $request = HTTP::Request::Common::POST(
#         $uri,
#         Content_Type => 'form-data',
#         Content      => []
#     );
#     return rb_exec_request($request);
# }

# sub rb_review_request_review_reply_draft_discard($ $) {
#     my $rid      = shift;
#     my $reviewid = shift;

#     my $uri = rb_uri(
#         "api/json/reviewrequests/$rid/reviews/$reviewid/draft/discard/");
#     my $request = HTTP::Request::Common::POST(
#         $uri,
#         Content_Type => 'form-data',
#         Content      => []
#     );
#     return rb_exec_request($request);
# }

# sub rb_review_request_diff_raw($) {
#     my $rid = shift;

#     my $uri     = rb_uri("r/$rid/diff/raw/");
#     my $request = HTTP::Request::Common::GET($uri);

#     my $response = http_transaction($request);
#     if ( !$response->is_success() ) {
#         my $errcode = $response->code();
#         my $errmsg  = $response->message();
#         die("Error: server returned error $errcode ($errmsg)\n");
#     }
#     return $response->content();
# }

sub rb_upload_diff {
    my $rid       = shift;
    my $basedir   = shift;
    my $diff_text = shift;

    my $uri     = rb_uri("api/review-requests/$rid/diffs/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [
            'basedir' => $basedir,
            'path'    => [ undef, 'diff', Content => $diff_text ]
        ]
    );
    return rb_exec_request($request);
}

sub rb_diff_header($ $ $) {
    my $depot_file = shift;
    my $depot_rev  = shift;
    my $local_file = shift;

    my @lt;
    if ( defined($local_file) ) {
        my @st = stat($local_file);
        @lt = localtime( $st[9] );
    }
    else {
        @lt = localtime(time);
    }
    my $ts = sprintf(
        "%04d-%02d-%02d %02d:%02d:%02d",
        $lt[5] + 1900,
        $lt[4] + 1,
        $lt[3], $lt[2], $lt[1], $lt[0]
    );

    my @dh;
    push( @dh, "--- $depot_file\t$depot_file#$depot_rev\n" );
    push( @dh, "+++ $depot_file\t$ts\n" );
    return @dh;
}

###
### p4
###

sub p4_info() {
    my %info;
    open( FH, "p4 info|" ) or return;
    while (<FH>) {
        chomp;
        my ( $key, $val ) = split( /:/, $_, 2 );
        stripws($val);
        $info{$key} = $val;
    }
    if ( !defined( $info{'Server address'} ) ) {
        die("Error: cannot load p4 info.\n");
    }
    return %info;
}

sub p4_config_load() {
    open( FH, "<$home/.p4config" ) or return;
    my $line;
    while ( $line = <FH> ) {
        chomp($line);
        next if ( $line =~ /^\s*$/ || $line =~ /^\s*#/ );
        my ( $key, $val ) = split( /=/, $line, 2 );
        stripws($key);
        stripws($val);
        if ( substr( $key, 0, 2 ) ne 'P4' ) {
            die("Invalid key in $home/.p4config: $key\n");
        }
        $ENV{$key} = $val;
    }
    delete $ENV{'P4DIFF'};
}

my @p4_cset_required_fields
    = ( 'Change', 'Date', 'Client', 'User', 'Status', 'Description' );

sub p4_cset_validate(\%) {
    my $cset = shift;

    my $field;

    foreach $field (@p4_cset_required_fields) {
        if ( !defined( $cset->{$field} ) ) {
            die("Missing required field $field in Perforce changeset\n");
        }
    }
}

sub p4_cset_owner($) {
    my $cset_id = shift;
    my %cset    = p4_cset_get($cset_id);

    # p4_cset_get validates the fields in the cl, so we know it has a
    # 'User' field.
    return $cset{'User'};
}

sub p4_cset_get($) {
    my $cset_id = shift;

    my %cset;
    my @lines;
    my $line;

    open( FH, "p4 change -o $cset_id|" )
        or die("Cannot get Perforce changeset\n");
    while ( $line = <FH> ) {
        chomp($line);
        push( @lines, $line );
        verbose( 4, "cset< $line\n" );
    }
    close(FH);
    if ( $? != 0 ) {
        die("Error: p4 change failed: error code $?\n");
    }
    foreach $line (@lines) {
        next if ( $line eq '' || $line =~ /^\s*#/ );
        if ( $line =~ /^(\w+):\s*(\S.*)/ ) {
            $cset{$1} = $2;
        }
        elsif ( $line =~ /^(\w+):/ ) {
            $field = $1;
            next;
        }
        else {
            if ( !$field ) {
                die("Unrecognized line in Perforce changeset: $line\n");
            }
            if ( substr( $line, 0, 1 ) ne "\t" ) {
                die("Expected leading tab in Perforce changeset: $line\n");
            }
            push( @{ $cset{$field} }, substr( $line, 1 ) );
        }
    }

    p4_cset_validate(%cset);

    return %cset;
}

sub p4_cset_put(\%) {
    my $cset = shift;

    my @lines;
    my $line;

    p4_cset_validate(%$cset);

    push( @lines, "Change: $cset->{'Change'}" );
    push( @lines, "" );
    push( @lines, "Date: $cset->{'Date'}" );
    push( @lines, "" );
    push( @lines, "Client: $cset->{'Client'}" );
    push( @lines, "" );
    push( @lines, "User: $cset->{'User'}" );
    push( @lines, "" );
    push( @lines, "Status: $cset->{'Status'}" );
    push( @lines, "" );

    push( @lines, "Description:" );
    foreach $line ( @{ $cset->{'Description'} } ) {
        push( @lines, "\t$line" );
    }
    push( @lines, "" );

    push( @lines, "Files:" );
    foreach $line ( @{ $cset->{'Files'} } ) {
        push( @lines, "\t$line" );
    }
    push( @lines, "" );

    push( @lines, "Jobs:" );
    foreach $line ( @{ $cset->{'Jobs'} } ) {
        push( @lines, "\t$line" );
    }
    push( @lines, "" );

    open( FH, "|p4 change -i" ) or die("Cannot set Perforce changeset\n");
    foreach $line (@lines) {
        print FH "$line\n";
        verbose( 4, "cset> $line\n" );
    }
    close(FH);
    if ( $? != 0 ) {
        die("Error: p4 change failed: error code $?\n");
    }
}

sub p4_cset_set(\% $ $) {
    my $cset = shift;
    my $key  = shift;
    my $val  = shift;

    $cset->{$key} = $val;

    p4_cset_validate(%$cset);
}

sub p4_cset_get_meta(\% $) {
    my $cset = shift;
    my $key  = shift;

    my $val = '';

    my $n = 0;
    my $line;
    my $found = 0;

    for ( $n = 0; $n < scalar( @{ $cset->{'Description'} } ); ++$n ) {
        $line = $cset->{'Description'}[$n];
        if (   substr( $line, 0, length($key) ) eq $key
            && substr( $line, length($key), 1 ) eq ':' )
        {
            $val = substr( $line, length($key) + 1 );
            stripws($val);
            last;
        }
    }

    return $val;
}

sub p4_cset_set_meta(\% $ $) {
    my $cset = shift;
    my $key  = shift;
    my $val  = shift;

    my $n = 0;
    my $line;
    my $found = 0;

    for ( $n = 0; $n < scalar( @{ $cset->{'Description'} } ); ++$n ) {
        $line = $cset->{'Description'}[$n];
        if (   substr( $line, 0, length($key) ) eq $key
            && substr( $line, length($key), 1 ) eq ':' )
        {
            $cset->{'Description'}[$n] = "$key: $val";
            return;
        }
    }

    if ( $cset->{'Description'}[-1] !~ /^\w+:/ ) {
        push( @{ $cset->{'Description'} }, "" );
    }
    push( @{ $cset->{'Description'} }, "$key: $val" );
}

sub p4_submit_cset($ $) {

    # TODO: This needs to return the submitted change list number.
    my ( $cset_id, $edit ) = @_;

    if ($edit) {
        system("p4 change $cset_id");
        if ( $? != 0 ) {
            die("Error: p4 change failed: error code $?\n");
        }
        my $submit
            = prompt_y_or_n( 'Submit to perforce and close review?', 'n' );
        unless ($submit) {
            print "Submit cancelled.\n";
            exit 0;
        }
    }
    system("p4 submit -c $cset_id");
    if ( $? != 0 ) {
        die("Error: p4 submit failed: error code $?\n");
    }
}

sub p4_delete_shelve($) {
    my $cset_id = shift;

    system("p4 shelve -d -c $cset_id");
    if ( $? != 0 ) {
        die( "Error: p4 shelve -d -c $cset_id command failed: error code $?\n"
        );
    }
}

sub p4_update_shelve($ $) {
    my $rid     = shift;
    my $cset_id = shift;
    my $comment = "";

    system("p4 shelve -r -c $cset_id");
    if ( $? != 0 ) {
        die("Error: p4 shelve command failed: error code $?\n");
    }
}

sub p4_change_is_shelved($) {
    my $cset_id  = shift;
    my $line     = "";
    my $desc_cmd = "p4 describe -s -S $cset_id";

    open( F, "$desc_cmd|" ) or die "Error: could not run $desc_cmd:$!\n";

    # Keep scanning until we see Shelved files ...
    while ( $line !~ /^Shelved files \.\.\./ ) {
        if ( $line =~ /^Affected files \.\.\./ ) {

            # Shelved changes would never say this
            close(F);
            return 0;
        }
        if ( !chomp( $line = <F> ) ) {
            die "Error: prematurely reached end of $desc_cmd output.\n";
        }
    }

    # An unshelved change would still match "Shelved files ..."
    # however, there would be no files listed afterward.

    while (<F>) {
        if (/\S+/) {

            # we found something after Shelved files..., so this must be
            # a shelved change.
            close(F);
            return 1;
        }
    }

    close(F);
    return 0;
}

sub p4_diff_file($ $ $ $) {
    my $depot_file  = shift;
    my $depot_rev   = shift;
    my $change_type = shift;
    my $pending     = shift;

    my $local_file;
    my @diff_lines = ();

    # set local_file if pending change
    if ($pending) {
        my @where_lines = `p4 where "$depot_file"`;
        if ( $? != 0 || scalar(@where_lines) == 0 ) {
            die("Error: failed command: p4 where \"$depot_file\"\n");
        }
        chop(@where_lines);
        my @where_fields = split( / /, pop(@where_lines), 3 );
        $local_file = $where_fields[2];
    }

    if ( !$pending ) {
        my $prev_depot_rev = $depot_rev;
        --$prev_depot_rev;
        @diff_lines
            = `p4 diff2 -du "$depot_file#$prev_depot_rev" "$depot_file#$depot_rev"`;
        if ( $? != 0 || scalar(@diff_lines) == 0 ) {
            die("Error: failed command: p4 diff2 -du \"$depot_file#$prev_depot_rev\" \"$depot_file#$depot_rev\"\n"
            );
        }
        if ( $diff_lines[0] !~ /^==== (.*) - (.*) ===/ ) {
            die("Error: unknown p4 diff header $diff_lines[0]\n");
        }
        if ( $diff_lines[0] =~ /^==== (.*) - (.*) ===.*binary.*/ ) {
            warn(
                "$depot_file is a binary file and diff will not be included in review\n"
            );
            return;
        }
        if ( $diff_lines[0] =~ /^==== <none> - (.*) ===*/ ) {

            # this is a new file, write out to temp file
            use File::Temp qw/:mktemp/;
            my $tmpfile = mktemp("rbtmp.XXXXXX");
            my $cmd     = "p4 print \"$depot_file#$depot_rev\" > $tmpfile";
            verbose( 2, "$cmd\n" );
            `$cmd`;
            $cmd = "diff -du /dev/null $tmpfile";
            verbose( 2, "$cmd\n" );
            @diff_lines = `$cmd`;
            unlink($tmpfile);

            if ( scalar(@diff_lines) < 2 ) {
                warn(
                    "Warning: couldn't get diff for added file (non-pending changelist)\n"
                );
            }
            $diff_lines[0] = "--- \t$depot_file#$prev_depot_rev\n";
            $diff_lines[1] = "+++ \t" . time() . "\n";
            return @diff_lines;
        }
        shift(@diff_lines);
        if ( scalar(@diff_lines) == 0 ) {
            warn(
                "$depot_file in your changeset is unmodified and will not be included in review\n"
            );
            return;
        }
        unshift( @diff_lines,
            rb_diff_header( $depot_file, $prev_depot_rev, undef ) );
    }
    elsif ( $change_type eq 'edit' || $change_type eq 'integrate' ) {

        # skip binary files
        if ( -B "$local_file" ) {
            warn(
                "$local_file is a binary file - it will not be included in review\n"
            );
            return;
        }
        @diff_lines = `p4 diff -du "$depot_file"`;
        if ( $? != 0 ) {
            die("Error: failed command: p4 diff -du \"$depot_file\"\n");
        }
        if ( scalar(@diff_lines) != 0 ) {
            if ( $diff_lines[0] =~ /^==== (.*) - (.*) ====.*binary.*/ ) {
                warn(
                    "$depot_file is a binary file and will not be included in review\n"
                );
                return;
            }

            # The first two lines are the header...
            shift(@diff_lines);
            shift(@diff_lines);
        }
        if ( scalar(@diff_lines) == 0 ) {
            warn(
                "$depot_file in your changeset is unmodified and will not be included in review\n"
            );
            return;
        }
        unshift( @diff_lines,
            rb_diff_header( $depot_file, $depot_rev, $local_file ) );
    }
    elsif ($change_type eq 'add'
        || $change_type eq 'branch'
        || $change_type eq 'move/add' )
    {
        open( ORIG, $local_file );
        while (<ORIG>) {
            chomp;
            push( @diff_lines, "+$_\n" );
        }
        close(ORIG);

# Empty files, such as __init__.py, cause RB to choke, so if this file is empty
# keep RB happy by adding a blank line to @diff_lines. Note the actual file is not
# modified.
        unless (@diff_lines) {
            push @diff_lines, "+\n";
        }

        unshift( @diff_lines, "@@ -0,0 +1," . scalar(@diff_lines) . " @@\n" );
        unshift( @diff_lines,
            rb_diff_header( $depot_file, $depot_rev, $local_file ) );
    }
    elsif ( $change_type eq 'delete' || $change_type eq 'move/delete' ) {
        open( ORIG, "p4 print -q $depot_file|" )
            || die("Can't run 'p4 print -q $depot_file'");
        while (<ORIG>) {
            push( @diff_lines, "-$_" );
        }
        close(ORIG);

        my $line_count = @diff_lines;
        if ( $line_count == 0 ) {
            warn("$depot_file is zero length, ignoring.\n");
            return;
        }

 # If the original file doesn't end with a newline, we need to tell patch
 # with the special string: \ No newline at end of file. We don't include this
 # line in the line count.
        my $last_line = $diff_lines[-1];
        if ( not chomp($last_line) ) {
            push @diff_lines, "\n\\ No newline at end of file\n";
        }

        unshift( @diff_lines, "@@ -1," . $line_count . " +0,0 @@\n" );
        unshift( @diff_lines,
            rb_diff_header( $depot_file, $depot_rev, undef ) );
    }
    else {
        die("Error: unknown change type $change_type for $depot_file\n");
    }
    return @diff_lines;
}

sub p4_diff_cset($) {
    my $cset       = shift;
    my @cset_lines = `p4 describe -s $cset`;
    if ( $? != 0 || scalar(@cset_lines) < 2 ) {
        die("Error: cannot describe changeset $cset\n");
    }
    chop(@cset_lines);
    my $pending = ( $cset_lines[0] =~ /\*pending\*$/ );

    my @diff_lines;
    my $in_affected_files = 0;
    my $cset_line;
    foreach $cset_line (@cset_lines) {
        if ( $cset_line eq '' ) {
            next;
        }
        if ( $cset_line =~ /^Affected files/ ) {
            $in_affected_files = 1;
            next;
        }
        if ( !$in_affected_files ) {
            next;
        }
        if ( $cset_line !~ /\.\.\. (.+)#(\d+) (\S+)/ ) {
            die("Error: invalid text in change description: $cset_line\n");
        }
        my $depot_file  = $1;
        my $depot_rev   = $2;
        my $change_type = $3;
        push( @diff_lines,
            p4_diff_file( $depot_file, $depot_rev, $change_type, $pending ) );
    }
    return @diff_lines;
}

sub p4_diff_opened() {
    my @opened_lines = `p4 opened`;
    if ( $? != 0 || scalar(@opened_lines) == 0 ) {
        die("Error: no opened files\n");
    }
    chomp(@opened_lines);

    my @diff_lines;
    my $opened_line;
    foreach $opened_line (@opened_lines) {
        if ( $opened_line !~ /^(\S+)#(\d+) - (\S+)/ ) {
            die("Error: invalid text in opened files: $opened_line\n");
        }
        my $depot_file  = $1;
        my $depot_rev   = $2;
        my $change_type = $3;
        push( @diff_lines,
            p4_diff_file( $depot_file, $depot_rev, $change_type, 1 ) );
    }
    return @diff_lines;
}

########################################
### Main helpers

my $rr_editargs_help
    = "editargs:\n"
    . "\t--changeset=NUMBER\n"
    . "\t--bugs=STRING (or --cr)\n"
    . "\t--target-groups=STRING (or --tg)\n"
    . "\t--target-people=STRING (or --tp)\n"
    . "\t--summary=STRING\n"
    . "\t--description=STRING\n"
    . "\t--status=<submitted|discarded|reopen>\n"
    . "\t--submit-as=STRING\n"
    . "\t--publish\n"
    . "\t--shelve\n"
    . "\t(Note: Perforce changeset description is used by default)\n"
    . "\t--update-description\n"
    . "\t--update-bugs\n"
    . "\t--update-summary\n"
    . "\t--update-diff\n"
    . "\t--update-all\n"
    . "\t(This would update description, summary, bugs, and diff\n"
    . "\t from perforce changeset)\n";
my $rr_listargs_help
    = "listargs:\n"
    . "\t--status=<pending|submitted|discarded|reopen> (default: pending)\n"
    . "\t--to-group=STRING (or --tg)\n"
    . "\t--to-person=STRING (or --tp) [Use \".\" for self]\n"
    . "\t--from-person=STRING (or --fp) [Use \".\" for self]\n";

my %sub_cmds = (
    'create' => "[editargs...]\n"
        . "Create a new reviewrequest\n"
        . $rr_editargs_help,
    'edit' => "[editargs...] ID\n"
        . "Edit an existing reviewrequest\n"
        . $rr_editargs_help,
    'show' => "[--diff] ID ...\n"
        . "Show given reviewrequest(s), optionally with diff\n",
    'submit' => "[--asis] [--force] [--edit] ID\n"
        . "Submit given reviewrequest. \n\t--asis   Don't check for or add reviewers names.\n\t--force  Submit even if not reviewed.\n\t--edit   Edit changelist first.\n",
    'review'      => "ID\n" . "Create review for given reviewrequest\n",
    'reviews'     => "ID\n" . "Show reviews for given reviewrequest\n",
    'reviewreply' => "ID ID\n" . "Reply to given reviewrequest review\n",
    'list'        => "[listargs...]\n"
        . "List reviewrequests matching given criteria\n"
        . $rr_listargs_help,
    'publish' => "ID ...\n" . "Publish given reviewrequest(s)\n",
);
my %sub_abbr = (
    'new' => 'create',

    #'ufc' => 'update',
    'del' => 'delete'
);

my %top_cmds = (
    'help' => "\n" . "This text\n",
    'pref' => "key [val]\n"
        . "Get or set preferences.  Some useful preferences:\n"
        . "\tuse_ssl [0|1]\n"
        . "\tserver STRING\n"
        . "\tusername STRING\n"
        . "\tuse_color [0|1]\n"
        . "\ttimeout SECONDS\n",
    'login' =>
        "[--ssl|--nossl] [--server=STRING] [--password=STRING] [username]\n"
        . "Login to reviewboard server.\n",
    'reviewrequest' => "[subcommand] [args]\n"
        . "Manipulate reviewrequest object.\n"
        . "Subcommands:\n\t"
        . join( "\n\t", keys(%sub_cmds) ) . "\n"
        . "For help on a specific subcommand, try \"$0 help reviewrequest <subcommand>\"\n",
    'repositories' => "\n" . "Show available repositories\n",
    'users'  => "[query]\n" . "Show users, optionally matching given query\n",
    'groups' => "[query]\n"
        . "Show groups, optionally matching given query\n",
    'group' => "<--star|--unstar> [name ...]\n"
        . "Manipulate given groups(s)\n",
    'diff' => "[--changeset=NUMBER]\n"
        . "Show current diff in reviewboard format\n"
);
my %top_abbr = (
    'rr'      => 'reviewrequest',
    'request' => 'reviewrequest',
    'repos'   => 'repositories'
);

sub usage() {
    print STDERR "$0 [-v|-q ...] [command] [args...]\n" . "Commands:\n";
    foreach ( keys %top_cmds ) {
        print "\t$_\n";
    }
    print STDERR
        "For help on a specific command, try \"$0 help <command>\"\n";
    exit(0);
}

# sub print_repo(\%) {
#     my $r = shift;
#     print "$r->{'name'}: $r->{'tool'} repo at $r->{'path'}\n";
# }

# sub print_user(\%) {
#     my $u = shift;
#     my $pad = " " x ( 16 - length( $u->{'username'} ) );

#     print "$u->{'username'}$pad$u->{'fullname'} $u->{'email'}\n";
# }

# sub print_group(\%) {
#     my $g = shift;
#     my $pad = " " x ( 16 - length( $g->{'name'} ) );

#     print "$g->{'name'}$pad$g->{'display_name'}\n";
# }

# sub print_rr_summary(\%) {
#     my $rr  = shift;
#     my $rid = $rr->{'id'};

#     my $h = "Review Request $rid (" . rb_uri("r/$rid/") . ")";
#     print "$h\n" . "=" x length($h) . "\n";

#     my $n;
#     my $len;
#     print "Summary  : $rr->{'summary'}\n"
#         . "Submitter: $rr->{'submitter'}{'fullname'} "
#         . "<$rr->{'submitter'}{'email'}>\n"
#         . "Created  : $rr->{'time_added'}\n"
#         . "Updated  : $rr->{'last_updated'}\n"
#         . "Branch   : $rr->{'branch'}\n"
#         . "Status   : $rr->{'status'}\n"
#         . "Changeset: $rr->{'changenum'}\n";
#     print "Public   : " . bool_to_yn( $rr->{'public'} );

#     if ( !$rr->{'public'} ) {
#         if ( $prefs{'use_color'} ) {
#             print " " . color('red') . "[NOT PUBLISHED]" . color('reset');
#         }
#         else {
#             print " [NOT PUBLISHED]";
#         }
#     }
#     print "\n";
#     print "Bugs     : ";
#     if ( ref( $rr->{'bugs_closed'} ) eq 'ARRAY' ) {
#         print join( ', ', @{ $rr->{'bugs_closed'} } ) . "\n";
#     }
#     else {
#         print $rr->{'bugs_closed'} . "\n";
#     }
#     print "Groups   : ";
#     $len = scalar( @{ $rr->{'target_groups'} } );
#     for ( $n = 0; $n < $len; ++$n ) {
#         print $rr->{'target_groups'}[$n]{'display_name'};
#         print ", " unless ( $n == $len - 1 );
#     }
#     print "\n";
#     print "People   : ";
#     $len = scalar( @{ $rr->{'target_people'} } );
#     for ( $n = 0; $n < $len; ++$n ) {
#         print $rr->{'target_people'}[$n]{'fullname'};
#         print ", " unless ( $n == $len - 1 );
#     }
#     print "\n";
#     print "Description...\n" . $rr->{'description'} . "\n";
# }

# sub print_diff($) {
#     my $text = shift;

#     my $line;
#     my $color_pref_name;
#     foreach $line ( split( '\n', $text ) ) {
#         $color_pref_name = 'color_diff_context';
#         if ( $line =~ /^---/ ) {
#             $color_pref_name = 'color_diff_file_old';
#         }
#         elsif ( $line =~ /^\+\+\+/ ) {
#             $color_pref_name = 'color_diff_file_new';
#         }
#         elsif ( $line =~ /^@@/ ) {
#             $color_pref_name = 'color_diff_hunk';
#         }
#         elsif ( $line =~ /^-/ ) {
#             $color_pref_name = 'color_diff_line_del';
#         }
#         elsif ( $line =~ /^\+/ ) {
#             $color_pref_name = 'color_diff_line_add';
#         }

#         # else context or unrecognized

#         if ( $prefs{'use_color'} ) {
#             print color( $prefs{$color_pref_name} )
#                 . $line
#                 . color('reset') . "\n";
#         }
#         else {
#             print $line . "\n";
#         }
#     }
# }

# sub print_comment($ \%) {
#     my $indent = shift;
#     my $c      = shift;

#     my @lines;

#     push( @lines,
#               "> " x $indent
#             . "Comment $c->{'id'} from $c->{'user'}{'fullname'} at $c->{'timestamp'}"
#     );
#     push( @lines,
#               "> " x $indent
#             . "$c->{'filediff'}{'dest_file'} line $c->{'first_line'}" );
#     foreach ( split( "\n", $c->{'text'} ) ) {
#         push( @lines, "> " x $indent . $_ );
#     }

#     my $i = ( $indent < 3 ? $indent : 3 );

#     if ( $prefs{'use_color'} ) {
#         foreach (@lines) {
#             print color( $prefs{"color_indent$i"} )
#                 . $_
#                 . color('reset') . "\n";
#         }
#     }
#     else {
#         foreach (@lines) {
#             print $_ . "\n";
#         }
#     }
# }

# # XXX: This needs work, the display is not quite correct for threading.
# sub print_review($ $ \%);

# sub print_review($ $ \%) {
#     my $rid    = shift;
#     my $indent = shift;
#     my $r      = shift;

#     my $line;

#     print "| " x $indent
#         . "Review $r->{'id'} from $r->{'user'}{'fullname'} at $r->{'timestamp'}\n";
#     if ( $r->{'body_top'} ) {
#         foreach $line ( split( "\n", $r->{'body_top'} ) ) {
#             print "| " x $indent . $line . "\n";
#         }
#     }
#     if ( $r->{'body_bottom'} ) {
#         foreach $line ( split( "\n", $r->{'body_bottom'} ) ) {
#             print "| " x $indent . $line . "\n";
#         }
#     }
#     if ( $r->{'ship_it'} ) {
#         print "| " x $indent . "[Ship it!]\n";
#     }
#     print "\n";

#     my %replydata
#         = rb_review_request_review_reply_get_all( $rid, $r->{'id'} );
#     my @replies = @{ $replydata{'replies'} };
#     my $reply;
#     foreach $reply (@replies) {
#         print_review( $rid, $indent + 1, %$reply );
#     }

#     my @comments = @{ $r->{'comments'} };
#     my $comment;
#     foreach $comment (@comments) {
#         print_comment( $indent + 1, %$comment );
#     }
# }

sub do_help() {
    if ( scalar(@ARGV) == 0 ) {
        usage();
    }
    my $cmd = shift(@ARGV);
    if ( defined( $top_abbr{$cmd} ) ) {
        $cmd = $top_abbr{$cmd};
    }
    if ( $cmd eq 'reviewrequest' && scalar(@ARGV) > 0 ) {
        do_rr_help();
        return;
    }
    if ( defined( $top_cmds{$cmd} ) ) {
        print STDERR "$0 $cmd " . $top_cmds{$cmd};
    }
    else {
        usage();
    }
}

sub do_pref() {
    my $key = '';
    my $val = '';
    if ( scalar(@ARGV) == 1 ) {
        if ( $ARGV[0] =~ /=/ ) {
            ( $key, $val ) = split( /=/, $ARGV[0], 2 );
        }
        else {
            # Just display the key
            $key = $ARGV[0];
            if ( defined( $prefs{$key} ) ) {
                $val = $prefs{$key};
            }
            else {
                $val = '<undef>';
            }
            print "$key=$val\n";
            return;
        }
    }
    elsif ( scalar(@ARGV) == 2 ) {
        $key = $ARGV[0];
        $val = $ARGV[1];
    }
    else {
        usage();
    }
    $prefs{$key} = $val;
    prefs_save();
}

sub do_login() {
    my $opt_ssl      = undef;
    my $opt_server   = '';
    my $opt_username = '';
    my $opt_password = '';

    if (!GetOptions(
            'ssl!'       => \$opt_ssl,
            'server=s'   => \$opt_server,
            'password=s' => \$opt_password
        )
        )
    {
        usage();
    }
    if ( scalar(@ARGV) >= 1 ) {
        $opt_username = shift(@ARGV);
    }

    if ( defined($opt_ssl) ) {
        $prefs{'use_ssl'} = $opt_ssl;
    }
    if ($opt_server) {
        $prefs{'server'} = $opt_server;
    }

    if ($opt_username) {
        $prefs{'username'} = $opt_username;
    }
    if ( !defined( $prefs{'username'} ) ) {
        if ( defined( $ENV{'P4USER'} ) ) {
            $prefs{'username'} = $ENV{'P4USER'};
        }
        else {
            $prefs{'username'} = $ENV{'USER'};
        }
    }

    my $password = '';
    if ($opt_password) {
        $password = $opt_password;
    }
    if ( !$password ) {
        if ( defined( $ENV{'P4PASSWD'} ) ) {
            $password = $ENV{'P4PASSWD'};
        }
        else {
            system("stty -echo");
            print "Password: ";
            $password = <>;
            chop($password);
            print "\n";
            system("stty echo");
        }
    }

    rb_login($password);
    prefs_save();
    $ua->cookie_jar()->save();
}

# sub do_repositories() {
#     my %data  = rb_repositories();
#     my @repos = @{ $data{'repositories'} };
#     foreach (@repos) {
#         print_repo( %{$_} );
#     }
# }

# sub do_users() {
#     my $query = '';
#     if ( scalar(@ARGV) >= 1 ) {
#         $query = $ARGV[0];
#     }

#     my %data  = rb_users($query);
#     my @users = @{ $data{'users'} };
#     foreach (@users) {
#         print_user( %{$_} );
#     }
# }

# sub do_groups() {
#     my $query = '';
#     if ( scalar(@ARGV) >= 1 ) {
#         $query = $ARGV[0];
#     }

#     my %data   = rb_groups($query);
#     my @groups = @{ $data{'groups'} };
#     foreach (@groups) {
#         print_group( %{$_} );
#     }
# }

# sub do_group() {
#     my $opt_star   = '';
#     my $opt_unstar = '';

#     if (!GetOptions(
#             'star'   => \$opt_star,
#             'unstar' => \$opt_unstar
#         )
#         )
#     {
#         usage();
#     }
#     if ( $opt_star && $opt_unstar ) {
#         usage();
#     }
#     if ( !$opt_star && !$opt_unstar ) {
#         usage();
#     }

#     while ( scalar(@ARGV) >= 1 ) {
#         my $group = shift(@ARGV);
#         rb_group_star( $group, $opt_star );
#     }
# }

# sub do_diff() {
#     my $opt_cset = '';
#     if ( !GetOptions( 'changeset=s' => \$opt_cset ) ) {
#         usage();
#     }
#     if ( scalar(@ARGV) != 0 ) {
#         usage();
#     }

#     my @diff_lines;
#     if ($opt_cset) {
#         @diff_lines = p4_diff_cset($opt_cset);
#     }
#     else {
#         @diff_lines = p4_diff_opened();
#     }
#     foreach (@diff_lines) {
#         print $_;
#     }
# }

sub do_reviewrequest() {
    if ( scalar(@ARGV) == 0 ) {
        usage();
    }
    my $cmd = shift(@ARGV);
    if ( defined( $sub_abbr{$cmd} ) ) {
        $cmd = $sub_abbr{$cmd};
    }
    if ( defined( $sub_cmds{$cmd} ) ) {
        eval("do_rr_$cmd");
        die($@) if $@;
    }
    else {
        unshift( @ARGV, $cmd );
        do_rr_show();
    }
}

sub do_rr_help() {
    if ( scalar(@ARGV) == 0 ) {
        usage();
    }
    my $cmd = shift(@ARGV);
    if ( defined( $sub_abbr{$cmd} ) ) {
        $cmd = $sub_abbr{$cmd};
    }
    if ( defined( $sub_cmds{$cmd} ) ) {
        print STDERR "$0 reviewrequest $cmd " . $sub_cmds{$cmd};
    }
    else {
        usage();
    }
}

sub do_rr_create() {
    my $opt_cset        = '';
    my $opt_bugs        = '';
    my $opt_groups      = '';
    my $opt_people      = '';
    my $opt_summary     = '';
    my $opt_description = '';
    my $opt_status      = '';
    my $opt_submit_as   = '';
    my $opt_publish     = 0;
    my $opt_shelve      = 0;

    my @args = @ARGV;

    my %p4info = p4_info();

    if (!GetOptions(
            'changeset|cset=s'   => \$opt_cset,
            'bugs|cr=s'          => \$opt_bugs,
            'target-groups|tg=s' => \$opt_groups,
            'target-people|tp=s' => \$opt_people,
            'summary=s'          => \$opt_summary,
            'description=s'      => \$opt_description,
            'status=s'           => \$opt_status,
            'publish'            => \$opt_publish,
            'shelve'             => \$opt_shelve,
            'submit-as=s'        => \$opt_submit_as
        )
        )
    {
        usage();
    }
    if ( scalar(@ARGV) != 0 ) {
        usage();
    }

    # If no changeset is given, create one.
    if ( !$opt_cset ) {

        # We want to launch the user's editor via "p4 change" and extract the
        # changeset number from stdout.  Unfortunately, we can't do both with
        # a single command: backticks redirect stdio so that the editor cannot
        # be used and system() does not capture output.  So we use a tempfile.
        use File::Temp qw/:mktemp/;
        my $tmpfile = mktemp("rbtmp.XXXXXX");
        my $editor = $ENV{'P4EDITOR'} || $ENV{'EDITOR'} || 'vi';
        system("p4 change -o > $tmpfile");
        if ( $? != 0 || !-f $tmpfile ) {
            unlink($tmpfile);
            die("Cannot create new changeset\n");
        }
        my @st1 = stat($tmpfile);
        system("$editor $tmpfile");
        if ( $? != 0 || !-f $tmpfile ) {
            unlink($tmpfile);
            die("Edit failed for $tmpfile\n");
        }
        my @st2 = stat($tmpfile);
        if (   $st1[7] == $st2[7]
            && $st1[9] == $st2[9] )
        {
            die("No change, not creating review request\n");
        }
        my $change_cmd = ( $opt_shelve ? 'shelve' : 'change' );
        my @change_lines = `p4 $change_cmd -i < $tmpfile`;
        if ( $? != 0 ) {
            unlink($tmpfile);
            die("Cannot save changeset from $tmpfile\n");
        }
        chop(@change_lines);
        unlink($tmpfile);
        if ( $change_lines[0] !~ /Change (\d+) created/ ) {
            die("Cannot find changeset number.\n");
        }
        $opt_cset = $1;
    }
    else {
        # Make sure we own the changelist
        my $p4_user    = $p4info{'User name'};
        my $cset_owner = p4_cset_owner($opt_cset);
        unless ( $cset_owner eq $p4_user ) {
            die
                "ERROR: Perforce change $opt_cset is owned by $cset_owner - you are running as $p4_user.\n";
        }
    }

    if ( !$opt_bugs ) {
        my %cset = p4_cset_get($opt_cset);
        if ( $cset{'Jobs'} ) {

            # Note that Perforce requires multi line format for Jobs.  It
            # will ensure that there is exactly one job name per line, that
            # all job names exist, and that there is whitespace between the
            # job names and trailing octothorpe.  So all we need to do is
            # save the first word from each line in the Jobs field.
            my @jobs;
            foreach ( @{ $cset{'Jobs'} } ) {
                if (m/^\s*(\d+)/) {
                    push( @jobs, $1 );
                }
                else {
                    warn "WARN: Ignoring unrecognized bug number '$_'\n";
                }
            }
            $opt_bugs = join( ',', @jobs );
        }
        else {
            my $crtext = p4_cset_get_meta( %cset, 'CR' );
            if ( $crtext !~ /^\s*([\d,]*)\s*$/ ) {
                die("Invalid CR text \"$crtext\"\n");
            }
            $opt_bugs = $crtext;
        }
        if ($opt_bugs) {
            push( @args, "--bugs=$opt_bugs" );
        }
    }

    my @diff_lines   = p4_diff_cset($opt_cset);
    my $diff_content = '';
    foreach (@diff_lines) {
        $diff_content .= $_;
    }
    if ( !$diff_content ) {
        die("Diff is empty.\n");
    }

    my %data = rb_review_request_create( $p4info{'Server address'},
        $opt_cset, $opt_submit_as );
    my %rr  = %{ $data{'review_request'} };
    my $rid = $rr{'id'};

    # TODO: Don't think we need this because it's called in do_rr_edit()
    # if ($opt_shelve) {
    #     p4_update_shelve( $rid, $opt_cset );
    #     rb_review_request_add_shelve_comment($rid), $cset_id);
    # }

    rb_upload_diff( $rid, $p4info{'Server address'}, $diff_content );

    @ARGV = @args;
    push( @ARGV, $rid );
    do_rr_edit();

    if ($opt_publish) {

        # TODO: Fix this so it's like rr_edit

        # $rid has been pushed onto @ARGV at this point,
        # so do_rr_publish() will know about it.
        do_rr_publish();
        print "Review request $rid published (" . rb_uri("r/$rid/") . ")\n";
    }
    else {
        print "Review request $rid created (" . rb_uri("r/$rid/") . ")\n"
            . "Be sure to publish when finished.\n";
    }
}

sub do_rr_edit() {
    my $opt_cset               = '';
    my $opt_bugs               = '';
    my $opt_groups             = '';
    my $opt_people             = '';
    my $opt_summary            = '';
    my $opt_description        = '';
    my $opt_status             = '';
    my $opt_submit_as          = '';
    my $opt_update_description = 0;
    my $opt_update_summary     = 0;
    my $opt_update_bugs        = 0;
    my $opt_update_diff        = 0;
    my $opt_update_all         = 0;
    my $opt_shelve             = 0;
    my $opt_publish            = 0;

    if (!GetOptions(
            'changeset|cset=s'   => \$opt_cset,
            'bugs|cr=s'          => \$opt_bugs,
            'target-groups|tg=s' => \$opt_groups,
            'target-people|tp=s' => \$opt_people,
            'summary=s'          => \$opt_summary,
            'description=s'      => \$opt_description,
            'status=s'           => \$opt_status,
            'publish'            => \$opt_publish,
            'submit-as=s'        => \$opt_submit_as,
            'shelve'             => \$opt_shelve,
            'update-description' => \$opt_update_description,
            'update-summary'     => \$opt_update_summary,
            'update-bugs'        => \$opt_update_bugs,
            'update-diff'        => \$opt_update_diff,
            'update-all'         => \$opt_update_all
        )
        )
    {
        usage();
    }
    if ($opt_status) {
        if (   $opt_status ne 'submitted'
            && $opt_status ne 'discarded'
            && $opt_status ne 'reopen' )
        {
            usage();
        }
    }
    if ( scalar(@ARGV) != 1 ) {
        usage();
    }

    my $rid  = $ARGV[0];
    my %data = rb_review_request_get($rid);
    my %rr   = %{ $data{'review_request'} };

    my $changed = 0;
    if ($opt_cset) {
        rb_review_request_draft_set_field( $rid, 'changenum', $opt_cset );
        $rr{'changenum'} = $opt_cset;
        $changed = 1;
    }
    my %cset = p4_cset_get( $rr{'changenum'} );
    if ($opt_groups) {
        rb_review_request_draft_set_field( $rid, 'target_groups',
            $opt_groups );
        $rr{'target_groups'} = $opt_groups;
        $changed = 1;
    }
    if ($opt_people) {
        rb_review_request_draft_set_field( $rid, 'target_people',
            $opt_people );
        $rr{'target_people'} = $opt_people;
        $changed = 1;
    }

    # TODO: Consider limiting this to 2 choices like post-review does.
    if ( $opt_update_description || $opt_update_all ) {
        my $description = join( "\n", @{ $cset{'Description'} } );
        print "Updating description\n";
        rb_review_request_draft_set_field( $rid, 'description',
            $description );
        $rr{'description'} = join( '\n', @{ $cset{'Description'} } );
        $changed = 1;
    }
    if ( $opt_update_summary || $opt_update_all ) {
        my $summary = ${ $cset{'Description'} }[0];
        rb_review_request_draft_set_field( $rid, 'summary', $summary );
        $rr{'summary'} = ${ $cset{'Description'} }[0];
        $changed = 1;
    }
    if ($opt_update_all) {
        my @jobs;
        foreach ( @{ $cset{'Jobs'} } ) {
            m/^\s*(\S+)/;
            push( @jobs, $1 );
        }
        my $bugs = join( ',', @jobs );
        rb_review_request_draft_set_field( $rid, 'bugs_closed', $bugs );
        $rr{'bugs_closed'} = $bugs;
        $changed = 1;
    }
    if ($opt_summary) {
        rb_review_request_draft_set_field( $rid, 'summary', $opt_summary );
        $rr{'summary'} = $opt_summary;
        $changed = 1;
    }
    if ($opt_description) {
        rb_review_request_draft_set_field( $rid, 'description',
            $opt_description );
        $rr{'description'} = $opt_description;
        $changed = 1;
    }
    if ($opt_submit_as) {
        rb_review_request_draft_set_field( $rid, 'submit_as',
            $opt_submit_as );
        $rr{'submit_as'} = $opt_submit_as;
        $changed = 1;
    }
    if ( $opt_update_diff || $opt_update_all ) {
        my %p4info       = p4_info();
        my @diff_lines   = p4_diff_cset( $rr{'changenum'} );
        my $diff_content = '';
        foreach (@diff_lines) {
            $diff_content .= $_;
        }
        if ( !$diff_content ) {
            die("Diff is empty.\n");
        }

        if ($opt_shelve) {
            p4_update_shelve( $rid, $rr{'changenum'} );
            rb_review_request_add_shelve_comment( $rid, $rr{'changenum'} );
        }

        rb_upload_diff( $rid, $p4info{'Server address'}, $diff_content );

        $changed = 1;
    }

    if ($changed) {
        if ($opt_publish) {

   # TODO: Consider fixing rb_review_request_publish so it can be called here.
   #rb_review_request_publish($rid);
            rb_review_request_draft_save($rid);
            print "Review request $rid published ("
                . rb_uri("r/$rid/") . ")\n";
        }
    }

    if ($opt_status) {
        rb_review_request_set_status( $rid, $opt_status );
    }
}

# sub do_rr_update() {
#     if ( scalar(@ARGV) == 0 ) {
#         usage();
#     }
#     my $rid;
#     foreach $rid (@ARGV) {
#         rb_review_request_update($rid);
#     }
# }

# sub do_rr_show() {
#     my $opt_diff = '';
#     if ( !GetOptions( 'diff' => \$opt_diff ) ) {
#         usage();
#     }
#     if ( scalar(@ARGV) == 0 ) {
#         usage();
#     }
#     my $rid;
#     foreach $rid (@ARGV) {
#         my %data = rb_review_request_get($rid);
#         print_rr_summary( %{ $data{'review_request'} } );
#         if ($opt_diff) {
#             my $diff_text = rb_review_request_diff_raw($rid);
#             print "Diff...\n";
#             print_diff($diff_text);
#         }
#     }
# }

sub do_rr_submit() {
    my $opt_asis  = '';
    my $opt_force = 0;
    my $opt_edit  = 0;

    if (!GetOptions(
            'asis'  => \$opt_asis,
            'force' => \$opt_force,
            'edit'  => \$opt_edit
        )
        )
    {
        usage();
    }
    if ( scalar(@ARGV) != 1 ) {
        usage();
    }
    my $rid     = $ARGV[0];
    my %data    = rb_review_request_get($rid);
    my %rr      = %{ $data{'review_request'} };
    my $cset_id = $rr{'changenum'};
    if ( !$cset_id ) {
        die("Cannot find changeset in review request.\n");
    }
    if ( $rr{'status'} ne 'pending' ) {
        die("Review request is not pending\n");
    }

    my %cset = p4_cset_get($cset_id);
    if ( $cset{'Status'} ne 'pending' ) {
        if ( !$opt_force ) {
            die("Changeset is not pending\n");
        }
    }

    if ( $cset{'Status'} eq 'pending' ) {
        if ( !$opt_asis ) {
            my @reviewers = rb_review_request_review_get_ship_its($rid);
            if (@reviewers) {
                p4_cset_set_meta( %cset, 'Reviewed by',
                    join( ', ', @reviewers ) );
            }
            else {
                if ( !$opt_force ) {
                    die("No reviews marked Ship It\n");
                }
            }

            p4_cset_set_meta( %cset, 'Reviewboard', $rid );
            p4_cset_put(%cset);
        }
        if ( p4_change_is_shelved($cset_id) ) {
            if ($opt_force) {
                p4_delete_shelve($cset_id);
            }
            else {
                die "Error: Cannot submit a shelved change ($cset_id).\n"
                    . "       You may use --force to delete the shelved change\n"
                    . "       automatically prior to submit.\n";
            }
        }
        p4_submit_cset( $cset_id, $opt_edit );
    }
    rb_review_request_set_status( $rid, 'submitted' );
}

# sub do_rr_reviews() {
#     if ( scalar(@ARGV) != 1 ) {
#         usage();
#     }
#     my $rid = $ARGV[0];
#     my %data;

#     %data = rb_review_request_get($rid);
#     my $summary = $data{'review_request'}{'summary'};

#     %data = rb_review_request_review_get_all($rid);

#     my $h = "Reviews for $rid: $summary";
#     print "$h\n" . "=" x length($h) . "\n";

#     my @reviews = @{ $data{'reviews'} };
#     my $review;
#     foreach $review (@reviews) {
#         print_review( $rid, 0, %$review );
#         print "\n";
#     }
# }

# sub do_rr_review() {
#     if ( scalar(@ARGV) != 1 ) {
#         usage();
#     }
#     my $rid = $ARGV[0];

#     use File::Temp qw/:mktemp/;
#     my $tmpfile = mktemp("rbtmp.XXXXXX");
#     my $editor  = 'vi';
#     if ( defined( $ENV{'EDITOR'} ) ) {
#         $editor = $ENV{'EDITOR'};
#     }

#     open( FH, ">$tmpfile" ) or die("Cannot open $tmpfile ($!)\n");
#     print FH "Public: yes\n" . "ShipIt: no\n" . "Comments:\n" . "...\n";
#     close(FH);
#     my @st1 = stat($tmpfile);
#     system("$editor $tmpfile");
#     if ( $? != 0 || !-f $tmpfile ) {
#         die("Edit failed for $tmpfile ($!)\n");
#     }
#     my @st2 = stat($tmpfile);
#     if (   $st1[7] == $st2[7]
#         && $st1[9] == $st2[9] )
#     {
#         die("No change, not submitting review\n");
#     }

#     my $is_public = 0;
#     my $is_shipit = 0;
#     my $comments  = '';

#     my $in_comments = 0;
#     open( FH, "<$tmpfile" ) or die("Cannot open $tmpfile ($!)\n");
#     while (<FH>) {
#         chomp;
#         if ($in_comments) {
#             $comments .= "$_\n";
#             next;
#         }
#         if (m/^(\w+):\s*(.*)/) {
#             my $key = $1;
#             my $val = $2;
#             if ( $key eq 'Public' ) {
#                 $is_public = string_to_bool($val);
#             }
#             if ( $key eq 'ShipIt' ) {
#                 $is_shipit = string_to_bool($val);
#             }
#             if ( $key eq 'Comments' ) {
#                 $in_comments = 1;
#             }
#         }
#         else {
#             verbose( 1, "Ignore line $_\n" );
#         }
#     }
#     close(FH);
#     unlink($tmpfile);

#     rb_review_request_review_draft_publish( $rid, $is_shipit, $comments, '' );
# }

# sub do_rr_reviewreply() {
#     if ( scalar(@ARGV) != 2 ) {
#         usage();
#     }
#     my $rid      = $ARGV[0];
#     my $reviewid = $ARGV[1];

#     use File::Temp qw/:mktemp/;
#     my $tmpfile = mktemp("rbtmp.XXXXXX");
#     my $editor  = 'vi';
#     if ( defined( $ENV{'EDITOR'} ) ) {
#         $editor = $ENV{'EDITOR'};
#     }

#     open( FH, ">$tmpfile" ) or die("Cannot open $tmpfile ($!)\n");
#     print FH "Comments:\n" . "...\n";
#     close(FH);
#     my @st1 = stat($tmpfile);
#     system("$editor $tmpfile");
#     if ( $? != 0 || !-f $tmpfile ) {
#         die("Edit failed for $tmpfile ($!)\n");
#     }
#     my @st2 = stat($tmpfile);
#     if (   $st1[7] == $st2[7]
#         && $st1[9] == $st2[9] )
#     {
#         die("No change, not submitting review reply\n");
#     }

#     my $comments = '';

#     my $in_comments = 0;
#     open( FH, "<$tmpfile" ) or die("Cannot open $tmpfile ($!)\n");
#     while (<FH>) {
#         chomp;
#         if ($in_comments) {
#             $comments .= "$_\n";
#             next;
#         }
#         if (m/^(\w+):\s*(.*)/) {
#             my $key = $1;
#             my $val = $2;
#             if ( $key eq 'Comments' ) {
#                 $in_comments = 1;
#             }
#         }
#         else {
#             verbose( 1, "Ignore line $_\n" );
#         }
#     }
#     close(FH);
#     unlink($tmpfile);

#     rb_review_request_review_reply_draft_set( $rid, $reviewid, 'body_top',
#         $comments );
#     rb_review_request_review_reply_draft_publish( $rid, $reviewid );
# }

# sub do_rr_list() {
#     my $opt_status    = 'pending';
#     my $opt_to_group  = '';
#     my $opt_to_user   = '';
#     my $opt_from_user = '';

#     if (!GetOptions(
#             'status=s'         => \$opt_status,
#             'to-group|tg=s'    => \$opt_to_group,
#             'to-person|tp=s'   => \$opt_to_user,
#             'from-person|fp=s' => \$opt_from_user
#         )
#         )
#     {
#         usage();
#     }
#     if ( scalar(@ARGV) != 0 ) {
#         usage();
#     }
#     if (   $opt_status ne 'pending'
#         && $opt_status ne 'submitted'
#         && $opt_status ne 'discarded'
#         && $opt_status ne 'reopen' )
#     {
#         usage();
#     }

#     my %data;
#     if ($opt_to_group) {
#         %data = rb_review_request_get_to_group( $opt_to_group, $opt_status );
#     }
#     elsif ($opt_to_user) {
#         if ( $opt_to_user eq '.' ) {
#             $opt_to_user = $prefs{'username'};
#         }
#         %data = rb_review_request_get_to_user( $opt_to_user, $opt_status );
#     }
#     elsif ($opt_from_user) {
#         if ( $opt_from_user eq '.' ) {
#             $opt_from_user = $prefs{'username'};
#         }
#         %data
#             = rb_review_request_get_from_user( $opt_from_user, $opt_status );
#     }
#     else {
#         %data = rb_review_request_get_all($opt_status);
#     }

#     my @rrs = @{ $data{'review_requests'} };
#     my $rr;
#     foreach $rr (@rrs) {
#         print_rr_summary( %{$rr} );
#         print "\n";
#     }
# }

# sub do_rr_publish() {
#     if ( scalar(@ARGV) == 0 ) {
#         usage();
#     }
#     my $rid;
#     foreach $rid (@ARGV) {

#         # This is a bit convoluted.
#         # Publishing a review request means setting setting the public
#         # attribute to 1.  But for some reason the server will not publish
#         # a review request unless it has an associated draft.  We need to do
#         # something here to ensure that a draft exists, but we don't want to
#         # change the review request.  So we try to set the public attribute
#         # to 1 in the draft.  The server accepts this request and creates a
#         # draft, even though drafts do not actually have a public attribute.
#         rb_review_request_draft_set_field( $rid, 'public', 1 );
#         rb_review_request_publish($rid);
#     }
# }

########################################
### Main begin

delete $ENV{'P4DIFF'};

prefs_load();
p4_config_load();

$ua->cookie_jar(
    HTTP::Cookies->new(
        file         => $prefs{'cookiefile'},
        hide_cookie2 => 1
    )
);

$ua->timeout( $prefs{'timeout'} );

while ( scalar(@ARGV) > 0 ) {
    if ( $ARGV[0] eq '-q' || $ARGV[0] eq '--quiet' ) {
        shift(@ARGV);
        $verbose_level = 0;
    }
    elsif ( $ARGV[0] eq '-v' || $ARGV[0] eq '--verbose' ) {
        shift(@ARGV);
        ++$verbose_level;
    }
    elsif ( $ARGV[0] eq '-h' || $ARGV[0] eq '--help' ) {
        usage();
    }
    else {
        last;
    }
}
if ( scalar(@ARGV) == 0 ) {
    usage();
}
my $cmd = shift(@ARGV);
if ( defined( $top_abbr{$cmd} ) ) {
    $cmd = $top_abbr{$cmd};
}
if ( defined( $top_cmds{$cmd} ) ) {
    eval("do_$cmd");
    die($@) if $@;
}
else {
    unshift( @ARGV, $cmd );
    do_reviewrequest();
}

__END__

