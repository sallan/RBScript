#!/usr/bin/perl
#
# Perl replacement for Review Board's post-review script for use with perforce only.
#
# The docs for the Web API can be found here:
#
# http://www.reviewboard.org/docs/manual/dev/webapi/2.0/
#
# Copyright (C) 2013 F5 Networks, Inc.
#
# This script is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as
# published by the Free Software Foundation.

use strict 'refs';
use warnings;
use Data::Dumper;

use Getopt::Long;
use IPC::Open2;
use HTTP::Cookies;
use HTTP::Request;
use HTTP::Request::Common;
use HTTP::Response;
use LWP::UserAgent;

# Don't buffer stdout
$|++;

# Globals
my $home = $ENV{'HOME'};
my %prefs;
my $DEBUG = 0;

my %prefs_default = (
    'use_ssl'             => 1,
    'server'              => "reviewboard",
    'cookiefile'          => "$home/.rbcookies.txt",
    'use_color'           => 0,
    'timeout'             => 180,
    'color_indent1'       => 'green',
    'color_indent2'       => 'dark green',
    'color_indent3'       => 'dark green',
    'color_diff_file_old' => 'bold red',
    'color_diff_file_new' => 'bold green',
    'color_diff_hunk'     => 'magenta',
    'color_diff_context'  => 'reset',
    'color_diff_line_del' => 'red',
    'color_diff_line_add' => 'green'
);

my %custom_error_messages = (
    103 => "
############################################################
#
# ERROR: You are not logged in to reviewboard
#
# Please log in using your OLYMPUS credentials with this command:
# $0 login
#
############################################################

",
);

# Newer versions of LWP::UserAgent are stricter about checking ssl
# certificates, and ours fails. To get around this we use the new
# option to turn off hostname verification, but only on the newer
# versions.
my $ua;
if ( new_lwp($LWP::UserAgent::VERSION) ) {
    $ua = LWP::UserAgent->new(
        ssl_opts => { verify_hostname => 0, SSL_verify_mode => 0x00 } );
}
else {
    $ua = LWP::UserAgent->new();
}

sub new_lwp {
    my $lwp_version = shift;
    return 0 unless $lwp_version;

    # Every version of LWP I've seen begins with a digit. So any
    # version that doesn't start with a digit we'll treat as old. Easy
    # enough to fix later if this causes problems. Given that, we'll
    # just pull off the leading digit and compare it to the version we
    # consider new.
    my $is_new = 0;
    if ( $lwp_version =~ /^(\d+)/ ) {
        $is_new = ( $1 >= 6 );
    }
    return $is_new;
}

my $verbose_level = 1;

sub verbose {
    print STDERR $_[1] if ( $verbose_level >= $_[0] );
}

sub stripws {
    foreach (@_) {
        s/^\s+//;
        s/\s+$//;
    }
}

sub prompt_y_or_n {
    my ( $query, $default ) = @_;
    if ( $default eq 'y' ) {
        $query = "$query n|[y]: ";
    }
    else {
        $query = "$query y|[n]: ";
    }
    print $query;
    my $response = <STDIN>;
    chomp $response;
    $response ||= $default;
    return lc $response eq 'y';
}

sub http_transaction {
    my $request = shift;
    verbose( 4, ">>>\n" . $request->as_string() . ">>>\n" );
    my $response = $ua->request($request);
    verbose( 4, "<<<\n" . $response->as_string() . "<<<\n" );
    return $response;
}

###
### Preferences
###
my $prefs_file = "$home/.rbrc";

sub prefs_load {
    if ( open( FH, "<$prefs_file" ) ) {
        my $line;
        my ( $key, $val );
        while ( $line = <FH> ) {
            chomp($line);
            next if ( $line =~ /^\s*$/ || $line =~ /^\s*#/ );
            ( $key, $val ) = split( /=/, $line, 2 );
            stripws($key);
            stripws($val);
            $prefs{$key} = $val;
        }
        close(FH);
    }
    foreach $key ( keys %prefs_default ) {
        if ( !defined( $prefs{$key} ) ) {
            $prefs{$key} = $prefs_default{$key};
        }
    }
}

sub prefs_save {
    open( FH, ">$prefs_file" ) or return;
    my $key;
    foreach $key ( sort keys %prefs ) {
        print FH "$key=$prefs{$key}\n";
    }
    close(FH);
}

###
### JSON
###
my $json_indent_step = 2;

sub json_encode_scalar(\$);
sub json_encode_array($ \@);
sub json_encode_hash($ \%);

sub json_encode_scalar(\$) {
    my $v = $_[0];
    if ( $$v eq 'true' || $$v eq 'false' || $$v eq 'null' ) {
        return $$v;
    }
    if ( $$v =~ /^(-)?[0-9]+$/ ) {
        return $$v;
    }
    my $enc;
    my $n;
    my %json_escape_ctrl
        = ( "\b" => 'b', "\f" => 'f', "\n" => 'n', "\r" => 'r', "\t" => 't' );
    $enc .= "\"";
    for ( $n = 0; $n < length($$v); ++$n ) {
        my $c = substr( $$v, $n, 1 );
        if ( $c eq '\\' || $c eq '"' || $c eq '/' ) {
            $enc .= "\\$c";
        }
        elsif ( defined( $json_escape_ctrl{$c} ) ) {
            $enc .= "\\" . $json_escape_ctrl{$c};
        }
        else {
            $enc .= $c;
        }
    }
    $enc .= "\"";
    return $enc;
}

sub json_encode_array($ \@) {
    my $indent    = $_[0];
    my $data      = $_[1];
    my $datacount = scalar( @{$data} );
    my $enc;

    my $n = 0;
    while ( $n < $datacount ) {
        $enc .= " " x $indent;
        my $v = $data->[$n];
        my $r = ref($v);
        if ( $r eq '' ) {
            $v = \$data->[$n];
            $r = ref($v);
        }
        if ( $r eq 'SCALAR' ) {
            $enc .= json_encode_scalar($$v);
        }
        elsif ( $r eq 'ARRAY' ) {
            $enc .= "[\n";
            $enc .= json_encode_array( $indent + $json_indent_step, @$v );
        }
        elsif ( $r eq 'HASH' ) {
            $enc .= "{\n";
            $enc .= json_encode_hash( $indent + $json_indent_step, %$v );
        }
        else {
            die("json_encode: cannot encode type=$r\n");
        }
        ++$n;
        if ( $n < $datacount ) {
            $enc .= ",";
        }
        $enc .= "\n";
    }
    $indent -= $json_indent_step;
    $enc .= " " x $indent . "]";
    return $enc;
}

sub json_encode_hash($ \%) {
    my $indent    = $_[0];
    my $data      = $_[1];
    my $datacount = scalar( keys %{$data} );
    my $enc;

    my $n = 0;
    foreach my $key ( keys %$data ) {
        $enc .= " " x $indent;
        $enc .= "\"$key\" : ";
        my $v = $data->{$key};
        my $r = ref($v);
        if ( $r eq '' ) {
            $v = \$data->{$key};
            $r = ref($v);
        }
        if ( $r eq 'SCALAR' ) {
            $enc .= json_encode_scalar($$v);
        }
        elsif ( $r eq 'ARRAY' ) {
            $enc .= "[\n";
            $enc .= json_encode_array( $indent + $json_indent_step, @$v );
        }
        elsif ( $r eq 'HASH' ) {
            $enc .= "{\n";
            $enc .= json_encode_hash( $indent + $json_indent_step, %$v );
        }
        else {
            die("json_encode: cannot encode type=$r\n");
        }
        ++$n;
        if ( $n < $datacount ) {
            $enc .= ",";
        }
        $enc .= "\n";
    }
    $indent -= $json_indent_step;
    $enc .= " " x $indent . "}";
    return $enc;
}

sub json_encode(\%) {
    my $enc;
    $enc = "{\n";
    $enc .= json_encode_hash( $json_indent_step, %{ $_[0] } );
    $enc .= "\n";
    return $enc;
}

sub json_next_token(\$ \$) {
    my $enc    = $_[0];
    my $pos    = $_[1];
    my $enclen = length($$enc);

    while ( $$pos < $enclen && substr( $$enc, $$pos, 1 ) =~ /\s/ ) {
        ++$$pos;
    }
    if ( $$pos >= $enclen ) {
        warn("json_next_token: EOI\n");
        return '';
    }

    my $json_toks     = "{}:[],";
    my $json_numbegin = "-0123456789";
    my $json_numbody  = "0123456789.Ee";
    my %json_escape_ctrl
        = ( 'b' => "\b", 'f' => "\f", 'n' => "\n", 'r' => "\r", 't' => "\t" );

    my $tok = substr( $$enc, $$pos++, 1 );
    if ( index( $json_toks, $tok ) < 0 ) {
        if ( index( $json_numbegin, $tok ) >= 0 ) {
            while ( index( $json_numbody, substr( $$enc, $$pos, 1 ) ) >= 0 ) {
                $tok .= substr( $$enc, $$pos++, 1 );
            }
        }
        elsif ( $tok eq '"' ) {
            $tok = '';
            my $c;
            while ( ( $c = substr( $$enc, $$pos, 1 ) ) ne '"' ) {
                if ( $c eq '\\' ) {
                    ++$$pos;
                    $c = substr( $$enc, $$pos, 1 );
                    if ( $c eq '"' || $c eq '\\' || $c eq '/' ) {

                        # no-op
                    }
                    elsif ( defined( $json_escape_ctrl{$c} ) ) {
                        $c = $json_escape_ctrl{$c};
                    }
                    elsif ( $c eq 'u' ) {
                        my $h4 = substr( $$enc, $$pos + 1, 4 );
                        if ( $h4 !~ /[[:xdigit:]]{4}/i ) {
                            warn(
                                "json_next_token: unknown sequence \\u$h4\n");
                            $h4 = "003f";    # '?'
                        }
                        $c = chr( hex("0x$h4") );
                        $$pos += 4;
                    }
                    else {
                        warn("json_next_token: unknown sequence \\$c\n");
                    }
                }
                $tok .= $c;
                ++$$pos;
            }
            ++$$pos;
        }
        else {
            while ( $$pos < $enclen && substr( $$enc, $$pos, 1 ) =~ /\w/ ) {
                $tok .= substr( $$enc, $$pos++, 1 );
            }
            if ( $tok ne 'true' && $tok ne 'false' && $tok ne 'null' ) {
                warn("json_next_token: unknown token $tok\n");
            }
        }
    }
    verbose( 4, "json_next_token: tok=$tok\n" );
    return $tok;
}

sub json_decode_array(\$ \$);
sub json_decode_hash(\$ \$);

sub json_decode_array(\$ \$) {
    my $enc = $_[0];
    my $pos = $_[1];
    my $tok;
    my @data;

    $tok = json_next_token( $$enc, $$pos );
    while ( $tok ne ']' ) {
        if ( $tok eq '[' ) {
            my @a = json_decode_array( $$enc, $$pos );
            push( @data, \@a );
        }
        elsif ( $tok eq '{' ) {
            my %h = json_decode_hash( $$enc, $$pos );
            push( @data, \%h );
        }
        else {
            push( @data, $tok );
        }
        $tok = json_next_token( $$enc, $$pos );
        if ( $tok ne ',' && $tok ne ']' ) {
            die("json_decode_array: expected comma or close bracket\n");
        }
        if ( $tok eq ',' ) {
            $tok = json_next_token( $$enc, $$pos );
        }
    }
    return @data;
}

sub json_decode_hash(\$ \$) {
    my $enc = $_[0];
    my $pos = $_[1];
    my $tok;
    my %data;

    $tok = json_next_token( $$enc, $$pos );
    while ( $tok ne '}' ) {
        my $key = $tok;
        $tok = json_next_token( $$enc, $$pos );
        if ( $tok ne ':' ) {
            die("json_decode_hash: expected colon\n");
        }
        $tok = json_next_token( $$enc, $$pos );
        if ( $tok eq '[' ) {
            my @a = json_decode_array( $$enc, $$pos );
            $data{$key} = \@a;
        }
        elsif ( $tok eq '{' ) {
            my %h = json_decode_hash( $$enc, $$pos );
            $data{$key} = \%h;
        }
        else {
            $data{$key} = $tok;
        }
        $tok = json_next_token( $$enc, $$pos );
        if ( $tok ne ',' && $tok ne '}' ) {
            die("json_decode_hash: expected comma or close brace\n");
        }
        if ( $tok eq ',' ) {
            $tok = json_next_token( $$enc, $$pos );
        }
    }
    return %data;
}

sub json_decode(\$) {
    my $enc = $_[0];
    my $pos = 0;
    my %data;
    my $tok;
    $tok = json_next_token( $$enc, $pos );
    if ( $tok ne '{' ) {
        die("json_decode: expected open brace\n");
    }
    %data = json_decode_hash( $$enc, $pos );
    return %data;
}

# End JSON

###
### rb
###

sub rb_uri {
    my $path = shift;

    if ( $prefs{'use_ssl'} && !$ua->is_protocol_supported('https') ) {
        my $sandbox_identity_file = '/var/lib/host-class/identity';
        my $perl_ssl_pkg
            = 'http://dag.wieers.com/rpm/packages/perl-Crypt-SSLeay/perl-Crypt-SSLeay-0.56-1.el3.rf.i386.rpm';
        my $perl_ssl_pkg_localpath
            = "/tmp/perl-Crypt-SSLeay-0.56-1.el3.rf.i386.rpm";
        my $sandbox_name = '';
        if ( -f $sandbox_identity_file ) {
            open( FH, "<$sandbox_identity_file" );
            $sandbox_name = <FH>;
            chomp($sandbox_name);
            close(FH);
        }
        if ( $prefs{'use_ssl'} && $sandbox_name eq 'bering' ) {
            die(      "Perl SSL support missing from bering sandbox\n"
                    . "Please install $perl_ssl_pkg\n" );
        }
        else {
            die(      "LWP::UserAgent does not support https\n"
                    . "Perhaps you need to install perl-Crypt-SSLeay or your distro equivalent?\n"
            );
        }
    }

    my $uri = ( $prefs{'use_ssl'} ? "https://" : "http://" );
    $uri .= $prefs{'server'};
    $uri .= "/$path";

    return $uri;
}

sub rb_exec_request {
    my ($request) = @_;

    print Dumper($request) if $DEBUG;

    my $response = http_transaction($request);
    if ( !$response->is_success() ) {
        my $errcode = $response->code();
        if ( $errcode == 401 ) {

            # 401 means not authorized. Authenticate and try again.
            my ( $username, $password ) = do_login();
            $request->authorization_basic( $username, $password );
            $response = http_transaction($request);
        }
    }
    if ( !$response->is_success() ) {
        my $errcode = $response->code();
        my $errmsg  = $response->message();
        die("Error: server returned error $errcode ($errmsg)\n");
    }
    my $dc   = $response->content();
    my %data = json_decode($dc);
    if ( !defined( $data{'stat'} ) ) {
        die("Error: no stat returned from request\n");
    }
    if ( $data{'stat'} ne 'ok' ) {

        my $msg
            = "Error: server request failed...\n"
            . "\turi="
            . $request->uri() . "\n"
            . "\tstat="
            . $data{'stat'} . "\n"
            . "\tcode="
            . $data{'err'}{'code'} . "\n"
            . "\tmsg="
            . $data{'err'}{'msg'} . "\n"
            . "Full server response:\n"
            . json_encode(%data);

        if ( exists( $custom_error_messages{ $data{err}->{code} } ) ) {
            $msg .= "\n" . $custom_error_messages{ $data{err}->{code} };
        }

        die($msg);
    }
    verbose( 3,
              ">>>\n"
            . $request->method() . " "
            . $request->uri() . "\n" . ">>>\n" . "<<<\n"
            . json_encode(%data)
            . "<<<\n" );
    return %data;
}

sub rb_review_request_create {
    my ( $repo, $cset, $alias ) = @_;
    my $uri     = rb_uri("api/review-requests/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [
            'repository' => $repo,
            'changenum'  => $cset,
        ]
    );
    return rb_exec_request($request);
}

sub rb_review_request_get {
    my $rid = shift;

    my $uri     = rb_uri("api/review-requests/$rid/");
    my $request = HTTP::Request::Common::GET($uri);
    return rb_exec_request($request);
}

sub rb_review_request_publish {

    # With the new Review Board API, publish is the same as saving a draft.
    my ($rid) = @_;
    rb_review_request_draft_save($rid);
}

sub rb_review_request_add_shelve_comment {
    my ( $rid, $cset_id ) = @_;
    my $comment
        = "This change has been shelved in changeset $cset_id.\n"
        . "To unshelve this change into your workspace:\n\n"
        . "        p4 unshelve -s $cset_id\n";

    my $uri     = rb_uri("api/review-requests/$rid/reviews/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [
            'body_top' => $comment,
            'public'   => 1
        ]
    );
    return rb_exec_request($request);
}

sub rb_use_old_api {
    my $old_api = 1;
    my $version = rb_get_version();
    my @version = split( /\./, $version, 3 );
    if ( @version < 2 ) {
        die "ERROR: Unexpected RB version error: ", $version, "\n";
    }
    my ( $major, $minor ) = @version[ 0, 1 ];
    if ( $major > 1 ) {
        $old_api = 0;
    }
    else {
        if ( $minor > 5 ) {
            $old_api = 0;
        }
    }
    return $old_api;
}

sub rb_review_request_set_changelist {
    my ( $rid, $changelist ) = @_;
    my $uri;
    if ( rb_use_old_api() ) {
        return;
    }
    else {
        $uri = rb_uri("api/review-requests/$rid/");
    }
    my $request = HTTP::Request::Common::PUT( $uri,
        Content => "changenum=$changelist" );
    return rb_exec_request($request);
}

sub rb_review_request_set_status {
    my ( $rid, $status ) = @_;
    my $uri;
    if ( rb_use_old_api() ) {
        my $uri = rb_uri("api/json/reviewrequests/$rid/$status/");
        if ( "$status" eq "submitted" or "$status" eq "discarded" ) {
            $uri = rb_uri("api/json/reviewrequests/$rid/close/$status/");
        }

        my $request = HTTP::Request::Common::POST(
            $uri,
            Content_Type => 'form-data',
            Content      => [ 'id' => $rid ]
        );

      # This is unfortunate: $status returns HTTP code 302 with no content, so
      # we cannot use rb_exec_request()
        my $response = http_transaction($request);
        if ( !$response->is_success() && !$response->is_redirect() ) {
            my $errcode = $response->code();
            my $errmsg  = $response->message();
            die("Error: server returned error $errcode ($errmsg)\n");
        }
    }
    else {
        $uri = rb_uri("api/review-requests/$rid/");
        my $request
            = HTTP::Request::Common::PUT( $uri, Content => "status=$status" );
        return rb_exec_request($request);
    }
}

sub rb_review_request_draft_set_field {
    my ( $rid, $key, $val ) = @_;
    my $uri     = rb_uri("api/review-requests/$rid/draft/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [ $key => $val ]
    );
    return rb_exec_request($request);
}

sub rb_review_request_draft_save {
    my ($rid) = @_;

    my $uri     = rb_uri("api/review-requests/$rid/draft/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [ public => 1 ]
    );
    return rb_exec_request($request);
}

sub rb_review_request_review_get_all {
    my $rid     = shift;
    my $uri     = rb_uri("api/review-requests/$rid/reviews/");
    my $request = HTTP::Request::Common::GET($uri);
    return rb_exec_request($request);
}

sub rb_review_request_review_get_ship_its {
    my $rid         = shift;
    my %review_data = rb_review_request_review_get_all($rid);
    my @reviews     = @{ $review_data{'reviews'} };
    my @reviewers;
    my %reviewers;
    for my $review (@reviews) {
        if ( $review->{'ship_it'} eq 'true' ) {
            my $reviewer_name = rb_review_get_reviewer_name($review);
            $reviewers{$reviewer_name} = 1;
        }
    }
    return keys(%reviewers);
}

sub rb_review_get_reviewer_name {
    my ($review) = @_;
    my $uri      = $review->{'links'}->{'user'}->{'href'};
    my $request  = HTTP::Request::Common::GET($uri);
    my $user     = ( rb_exec_request($request) )[1];
    return $user->{'fullname'};
}

sub rb_get_review_id_from_changelist {
    my ($changelist)    = @_;
    my $uri             = rb_uri("api/review-requests?changenum=$changelist");
    my $request         = HTTP::Request::Common::GET($uri);
    my %response        = rb_exec_request($request);
    my $review_requests = $response{'review_requests'};
    my $rid;
    if (@$review_requests) {
        $rid = $review_requests->[0]->{'id'};
    }
    return $rid;
}

sub rb_upload_diff {
    my ( $rid, $basedir, $diff_text ) = @_;

    my $uri     = rb_uri("api/review-requests/$rid/diffs/");
    my $request = HTTP::Request::Common::POST(
        $uri,
        Content_Type => 'form-data',
        Content      => [
            'basedir' => $basedir,
            'path'    => [ undef, 'diff', Content => $diff_text ]
        ]
    );
    return rb_exec_request($request);
}

sub rb_diff_header {
    my ( $depot_file, $depot_rev, $local_file ) = @_;

    my @lt;
    if ( defined($local_file) ) {
        my @st = stat($local_file);
        @lt = localtime( $st[9] );
    }
    else {
        @lt = localtime(time);
    }
    my $ts = sprintf(
        "%04d-%02d-%02d %02d:%02d:%02d",
        $lt[5] + 1900,
        $lt[4] + 1,
        $lt[3], $lt[2], $lt[1], $lt[0]
    );

    my @dh;
    push( @dh, "--- $depot_file\t$depot_file#$depot_rev\n" );
    push( @dh, "+++ $depot_file\t$ts\n" );
    return @dh;
}

sub rb_get_version {
    my $rb_info = rb_get_api_info();
    return $rb_info->{'product'}->{'version'};
}

sub rb_get_api {
    my $api_uri = rb_uri('api/');
    my $request = HTTP::Request::Common::GET($api_uri);
    my %result  = rb_exec_request($request);
    return $result{'links'};
}

sub rb_get_api_info {
    my $api     = rb_get_api();
    my $uri     = $api->{'info'}->{'href'};
    my $request = HTTP::Request::Common::GET($uri);
    my %result  = rb_exec_request($request);
    return $result{'info'};
}

###
### p4
###

sub p4_info {
    my %info;
    open( FH, "p4 info|" ) or return;
    while (<FH>) {
        chomp;
        my ( $key, $val ) = split( /:/, $_, 2 );
        stripws($val);
        $info{$key} = $val;
    }
    if ( !defined( $info{'Server address'} ) ) {
        die("Error: cannot load p4 info.\n");
    }
    return %info;
}

sub p4_get_shelved_changelists {
    my ($p4_user) = @_;
    my @changelists;

    my $cmd = "p4 changes -u $p4_user -s shelved";
    open( FH, "$cmd |" ) or die "Failed to execute '$cmd'\n";
    while (<FH>) {
        chomp;
        my $changelist = ( split ' ', $_, 3 )[1];
        push @changelists, $changelist;
    }
    close FH or warn "'$cmd' returned a non-zero value.\n";
    return @changelists;
}

sub p4_config_load {
    open( FH, "<$home/.p4config" ) or return;
    my $line;
    while ( $line = <FH> ) {
        chomp($line);
        next if ( $line =~ /^\s*$/ || $line =~ /^\s*#/ );
        my ( $key, $val ) = split( /=/, $line, 2 );
        stripws($key);
        stripws($val);
        if ( substr( $key, 0, 2 ) ne 'P4' ) {
            die("Invalid key in $home/.p4config: $key\n");
        }
        $ENV{$key} = $val;
    }
    delete $ENV{'P4DIFF'};
}

my @p4_cset_required_fields
    = ( 'Change', 'Date', 'Client', 'User', 'Status', 'Description' );

sub p4_cset_validate(\%) {
    my $cset = shift;

    my $field;

    foreach $field (@p4_cset_required_fields) {
        if ( !defined( $cset->{$field} ) ) {
            die("Missing required field $field in Perforce changeset\n");
        }
    }
}

sub p4_cset_owner {
    my $cset_id = shift;
    my %cset    = p4_cset_get($cset_id);

    # p4_cset_get validates the fields in the cl, so we know it has a
    # 'User' field.
    return $cset{'User'};
}

sub p4_cset_get {
    my $cset_id = shift;

    my %cset;
    my @lines;
    my $line;

    open( FH, "p4 change -o $cset_id|" )
        or die("Cannot get Perforce changeset\n");
    while ( $line = <FH> ) {
        chomp($line);
        push( @lines, $line );
        verbose( 4, "cset< $line\n" );
    }
    close(FH);
    if ( $? != 0 ) {
        die("Error: p4 change failed: error code $?\n");
    }
    foreach $line (@lines) {
        next if ( $line eq '' || $line =~ /^\s*#/ );
        if ( $line =~ /^(\w+):\s*(\S.*)/ ) {
            $cset{$1} = $2;
        }
        elsif ( $line =~ /^(\w+):/ ) {
            $field = $1;
            next;
        }
        else {
            if ( !$field ) {
                die("Unrecognized line in Perforce changeset: $line\n");
            }
            if ( substr( $line, 0, 1 ) ne "\t" ) {
                die("Expected leading tab in Perforce changeset: $line\n");
            }
            push( @{ $cset{$field} }, substr( $line, 1 ) );
        }
    }

    p4_cset_validate(%cset);

    return %cset;
}

sub p4_cset_put(\%) {
    my $cset = shift;

    my @lines;
    my $line;

    p4_cset_validate(%$cset);

    push( @lines, "Change: $cset->{'Change'}" );
    push( @lines, "" );
    push( @lines, "Date: $cset->{'Date'}" );
    push( @lines, "" );
    push( @lines, "Client: $cset->{'Client'}" );
    push( @lines, "" );
    push( @lines, "User: $cset->{'User'}" );
    push( @lines, "" );
    push( @lines, "Status: $cset->{'Status'}" );
    push( @lines, "" );

    push( @lines, "Description:" );
    foreach $line ( @{ $cset->{'Description'} } ) {
        push( @lines, "\t$line" );
    }
    push( @lines, "" );

    push( @lines, "Files:" );
    foreach $line ( @{ $cset->{'Files'} } ) {
        push( @lines, "\t$line" );
    }
    push( @lines, "" );

    push( @lines, "Jobs:" );
    foreach $line ( @{ $cset->{'Jobs'} } ) {
        push( @lines, "\t$line" );
    }
    push( @lines, "" );

    open( FH, "|p4 change -i" ) or die("Cannot set Perforce changeset\n");
    foreach $line (@lines) {
        print FH "$line\n";
        verbose( 4, "cset> $line\n" );
    }
    close(FH);
    if ( $? != 0 ) {
        die("Error: p4 change failed: error code $?\n");
    }
}

sub p4_cset_set(\% $ $) {
    my $cset = shift;
    my $key  = shift;
    my $val  = shift;

    $cset->{$key} = $val;

    p4_cset_validate(%$cset);
}

sub p4_cset_get_meta(\% $) {
    my $cset = shift;
    my $key  = shift;

    my $val = '';

    my $n = 0;
    my $line;
    my $found = 0;

    for ( $n = 0; $n < scalar( @{ $cset->{'Description'} } ); ++$n ) {
        $line = $cset->{'Description'}[$n];
        if (   substr( $line, 0, length($key) ) eq $key
            && substr( $line, length($key), 1 ) eq ':' )
        {
            $val = substr( $line, length($key) + 1 );
            stripws($val);
            last;
        }
    }

    return $val;
}

sub p4_cset_set_meta(\% $ $) {
    my $cset = shift;
    my $key  = shift;
    my $val  = shift;

    my $n = 0;
    my $line;
    my $found = 0;

    for ( $n = 0; $n < scalar( @{ $cset->{'Description'} } ); ++$n ) {
        $line = $cset->{'Description'}[$n];
        if (   substr( $line, 0, length($key) ) eq $key
            && substr( $line, length($key), 1 ) eq ':' )
        {
            $cset->{'Description'}[$n] = "$key: $val";
            return;
        }
    }

    if ( $cset->{'Description'}[-1] !~ /^\w+:/ ) {
        push( @{ $cset->{'Description'} }, "" );
    }
    push( @{ $cset->{'Description'} }, "$key: $val" );
}

sub p4_submit_cset {
    my ( $cset_id, $edit ) = @_;

    if ($edit) {
        system("p4 change $cset_id");
        if ( $? != 0 ) {
            die("Error: p4 change failed: error code $?\n");
        }
        my $submit
            = prompt_y_or_n( 'Submit to perforce and close review?', 'n' );
        unless ($submit) {
            print "Submit cancelled.\n";
            exit 0;
        }
    }
    my $submit_cmd = "p4 -z tag submit -c $cset_id";
    my $submitted_change;
    open( SUBMIT, "$submit_cmd |" )
        or die "Failed to execute: $submit_cmd: $!, $?\n";
    while (<SUBMIT>) {
        chomp;
        if (m{\.\.\.\s+submittedChange\s+(\d+)}) {
            $submitted_change = $1;
            last;
        }
    }
    close SUBMIT or die "$submit_cmd returned an error: $!, $?\n";
    unless ( defined $submitted_change ) {
        warn
            "Unable to determine submitted change list number. Will not update change list number in review\n";
    }
    return $submitted_change;
}

sub p4_delete_shelve {
    my $cset_id = shift;

    system("p4 shelve -d -c $cset_id");
    if ( $? != 0 ) {
        die( "Error: p4 shelve -d -c $cset_id command failed: error code $?\n"
        );
    }
}

sub p4_update_shelve {
    my ( $rid, $cset_id ) = @_;
    my $comment = "";

    system("p4 shelve -r -c $cset_id");
    if ( $? != 0 ) {
        die("Error: p4 shelve command failed: error code $?\n");
    }
}

sub p4_change_is_shelved {
    my ($cset_id)       = @_;
    my %p4info          = p4_info();
    my @shelved_changes = p4_get_shelved_changelists( $p4info{'User name'} );
    return grep { $_ == $cset_id } @shelved_changes;
}

sub p4_diff_file {
    my ( $depot_file, $depot_rev, $change_type, $pending ) = @_;

    my $local_file;
    my @diff_lines = ();

    # set local_file if pending change
    if ($pending) {
        my @where_lines = `p4 where "$depot_file"`;
        if ( $? != 0 || scalar(@where_lines) == 0 ) {
            die("Error: failed command: p4 where \"$depot_file\"\n");
        }
        chop(@where_lines);
        my @where_fields = split( / /, pop(@where_lines), 3 );
        $local_file = $where_fields[2];
    }

    if ( !$pending ) {
        my $prev_depot_rev = $depot_rev;
        --$prev_depot_rev;
        @diff_lines
            = `p4 diff2 -du "$depot_file#$prev_depot_rev" "$depot_file#$depot_rev"`;
        if ( $? != 0 || scalar(@diff_lines) == 0 ) {
            die("Error: failed command: p4 diff2 -du \"$depot_file#$prev_depot_rev\" \"$depot_file#$depot_rev\"\n"
            );
        }
        if ( $diff_lines[0] !~ /^==== (.*) - (.*) ===/ ) {
            die("Error: unknown p4 diff header $diff_lines[0]\n");
        }
        if ( $diff_lines[0] =~ /^==== (.*) - (.*) ===.*binary.*/ ) {
            warn(
                "$depot_file is a binary file and diff will not be included in review\n"
            );
            return;
        }
        if ( $diff_lines[0] =~ /^==== <none> - (.*) ===*/ ) {

            # this is a new file, write out to temp file
            use File::Temp qw/:mktemp/;
            my $tmpfile = mktemp("rbtmp.XXXXXX");
            my $cmd     = "p4 print \"$depot_file#$depot_rev\" > $tmpfile";
            verbose( 2, "$cmd\n" );
            `$cmd`;
            $cmd = "diff -du /dev/null $tmpfile";
            verbose( 2, "$cmd\n" );
            @diff_lines = `$cmd`;
            unlink($tmpfile);

            if ( scalar(@diff_lines) < 2 ) {
                warn(
                    "Warning: couldn't get diff for added file (non-pending changelist)\n"
                );
            }
            $diff_lines[0] = "--- \t$depot_file#$prev_depot_rev\n";
            $diff_lines[1] = "+++ \t" . time() . "\n";
            return @diff_lines;
        }
        shift(@diff_lines);
        if ( scalar(@diff_lines) == 0 ) {
            warn(
                "$depot_file in your changeset is unmodified and will not be included in review\n"
            );
            return;
        }
        unshift( @diff_lines,
            rb_diff_header( $depot_file, $prev_depot_rev, undef ) );
    }
    elsif ( $change_type eq 'edit' || $change_type eq 'integrate' ) {

        # skip binary files
        if ( -B "$local_file" ) {
            warn(
                "$local_file is a binary file - it will not be included in review\n"
            );
            return;
        }
        @diff_lines = `p4 diff -du "$depot_file"`;
        if ( $? != 0 ) {
            die("Error: failed command: p4 diff -du \"$depot_file\"\n");
        }
        if ( scalar(@diff_lines) != 0 ) {
            if ( $diff_lines[0] =~ /^==== (.*) - (.*) ====.*binary.*/ ) {
                warn(
                    "$depot_file is a binary file and will not be included in review\n"
                );
                return;
            }

            # The first two lines are the header...
            shift(@diff_lines);
            shift(@diff_lines);
        }
        if ( scalar(@diff_lines) == 0 ) {
            warn(
                "$depot_file in your changeset is unmodified and will not be included in review\n"
            );
            return;
        }
        unshift( @diff_lines,
            rb_diff_header( $depot_file, $depot_rev, $local_file ) );
    }
    elsif ($change_type eq 'add'
        || $change_type eq 'branch'
        || $change_type eq 'move/add' )
    {
        open( ORIG, $local_file );
        while (<ORIG>) {
            chomp;
            push( @diff_lines, "+$_\n" );
        }
        close(ORIG);

# Empty files, such as __init__.py, cause RB to choke, so if this file is empty
# keep RB happy by adding a blank line to @diff_lines. Note the actual file is not
# modified.
        unless (@diff_lines) {
            push @diff_lines, "+\n";
        }

        unshift( @diff_lines, "@@ -0,0 +1," . scalar(@diff_lines) . " @@\n" );
        unshift( @diff_lines,
            rb_diff_header( $depot_file, $depot_rev, $local_file ) );
    }
    elsif ( $change_type eq 'delete' || $change_type eq 'move/delete' ) {
        open( ORIG, "p4 print -q $depot_file|" )
            || die("Can't run 'p4 print -q $depot_file'");
        while (<ORIG>) {
            push( @diff_lines, "-$_" );
        }
        close(ORIG);

        my $line_count = @diff_lines;
        if ( $line_count == 0 ) {
            warn("$depot_file is zero length, ignoring.\n");
            return;
        }

 # If the original file doesn't end with a newline, we need to tell patch
 # with the special string: \ No newline at end of file. We don't include this
 # line in the line count.
        my $last_line = $diff_lines[-1];
        if ( not chomp($last_line) ) {
            push @diff_lines, "\n\\ No newline at end of file\n";
        }

        unshift( @diff_lines, "@@ -1," . $line_count . " +0,0 @@\n" );
        unshift( @diff_lines,
            rb_diff_header( $depot_file, $depot_rev, undef ) );
    }
    else {
        die("Error: unknown change type $change_type for $depot_file\n");
    }
    return @diff_lines;
}

sub p4_diff_cset {
    my $cset       = shift;
    my @cset_lines = `p4 describe -s $cset`;
    if ( $? != 0 || scalar(@cset_lines) < 2 ) {
        die("Error: cannot describe changeset $cset\n");
    }
    chop(@cset_lines);
    my $pending = ( $cset_lines[0] =~ /\*pending\*$/ );

    my @diff_lines;
    my $in_affected_files = 0;
    my $cset_line;
    foreach $cset_line (@cset_lines) {
        if ( $cset_line eq '' ) {
            next;
        }
        if ( $cset_line =~ /^Affected files/ ) {
            $in_affected_files = 1;
            next;
        }
        if ( !$in_affected_files ) {
            next;
        }
        if ( $cset_line !~ /\.\.\. (.+)#(\d+) (\S+)/ ) {
            die("Error: invalid text in change description: $cset_line\n");
        }
        my $depot_file  = $1;
        my $depot_rev   = $2;
        my $change_type = $3;
        push( @diff_lines,
            p4_diff_file( $depot_file, $depot_rev, $change_type, $pending ) );
    }
    return @diff_lines;
}

sub p4_diff_opened {
    my @opened_lines = `p4 opened`;
    if ( $? != 0 || scalar(@opened_lines) == 0 ) {
        die("Error: no opened files\n");
    }
    chomp(@opened_lines);

    my @diff_lines;
    my $opened_line;
    foreach $opened_line (@opened_lines) {
        if ( $opened_line !~ /^(\S+)#(\d+) - (\S+)/ ) {
            die("Error: invalid text in opened files: $opened_line\n");
        }
        my $depot_file  = $1;
        my $depot_rev   = $2;
        my $change_type = $3;
        push( @diff_lines,
            p4_diff_file( $depot_file, $depot_rev, $change_type, 1 ) );
    }
    return @diff_lines;
}

sub do_login {
    my $opt_username = '';
    my $opt_password = '';

    # If no user name in prefs, try to find a default.
    if ( !defined( $prefs{'username'} ) ) {
        if ( defined( $ENV{'P4USER'} ) ) {
            $prefs{'username'} = $ENV{'P4USER'};
        }
        else {
            $prefs{'username'} = $ENV{'USER'};
        }
        prefs_save();
    }
    my $username = $prefs{'username'};
    die "Need a Review Board username.\n" unless $username;

    # Prompt user for password
    my $password = '';
    system("stty -echo");
    print "Password required for $username\n";
    print "Password: ";
    chomp( $password = <> );
    print "\n";
    system("stty echo");
    die "Empty password!\n" unless $password;
    return ( $username, $password );
}

sub do_rr_create {
    my ( $changenum, $opt ) = @_;
    my %p4info = p4_info();

    # If no changeset is given, create one.
    if ( not $changenum ) {

        # We want to launch the user's editor via "p4 change" and extract the
        # changeset number from stdout.  Unfortunately, we can't do both with
        # a single command: backticks redirect stdio so that the editor cannot
        # be used and system() does not capture output.  So we use a tempfile.
        use File::Temp qw/:mktemp/;
        my $tmpfile = mktemp("rbtmp.XXXXXX");
        my $editor = $ENV{'P4EDITOR'} || $ENV{'EDITOR'} || 'vi';
        system("p4 change -o > $tmpfile");
        if ( $? != 0 || !-f $tmpfile ) {
            unlink($tmpfile);
            die("Cannot create new changeset\n");
        }
        my @st1 = stat($tmpfile);
        system("$editor $tmpfile");
        if ( $? != 0 || !-f $tmpfile ) {
            unlink($tmpfile);
            die("Edit failed for $tmpfile\n");
        }
        my @st2 = stat($tmpfile);
        if (   $st1[7] == $st2[7]
            && $st1[9] == $st2[9] )
        {
            die("No change, not creating review request\n");
        }
        my $change_cmd = ( $opt->{'shelve'} ? 'shelve' : 'change' );
        my @change_lines = `p4 $change_cmd -i < $tmpfile`;
        if ( $? != 0 ) {
            unlink($tmpfile);
            die("Cannot save changeset from $tmpfile\n");
        }
        chop(@change_lines);
        unlink($tmpfile);
        if ( $change_lines[0] !~ /Change (\d+) created/ ) {
            die("Cannot find changeset number.\n");
        }
        $changenum = $1;
    }
    else {
        # Make sure we own the changelist
        my $p4_user    = $p4info{'User name'};
        my $cset_owner = p4_cset_owner($changenum);
        unless ( $cset_owner eq $p4_user ) {
            die
                "ERROR: Perforce change $changenum is owned by $cset_owner - you are running as $p4_user.\n";
        }
    }

    my @diff_lines   = p4_diff_cset($changenum);
    my $diff_content = '';
    foreach (@diff_lines) {
        $diff_content .= $_;
    }
    if ( !$diff_content ) {
        die("Diff is empty.\n");
    }

    my %data
        = rb_review_request_create( $p4info{'Server address'}, $changenum );
    my %rr  = %{ $data{'review_request'} };
    my $rid = $rr{'id'};
    rb_upload_diff( $rid, $p4info{'Server address'}, $diff_content );

    # Set update-all to true and call do_rr_edit to finish creating the review.
    $opt->{'update-all'} = 1;
    do_rr_edit( $changenum, $opt, 1 );
}

sub do_rr_edit {
    my ( $changenum, $opt, $new_review ) = @_;

    unless ($changenum) {
        die "Need the changelist number for this review.\n";
    }

    my $rid = rb_get_review_id_from_changelist($changenum);
    unless ($rid) {
        die "Can't find an open review for change list: $changenum\n";
    }

    my %data = rb_review_request_get($rid);
    my %rr   = %{ $data{'review_request'} };

    # If we're updating status, just do that and exit.
    # TODO: Decide whether or not to suppor this. Currently disabled.
    if ($opt_status) {
        if (   $opt_status ne 'submitted'
            && $opt_status ne 'discarded'
            && $opt_status ne 'pending'
            && $opt_status ne 'reopen' )
        {
            usage();
        }
        else {
            # What we think of as reopen, RB calls pending.
            my $status = $opt_status eq 'reopen' ? 'pending' : $opt_status;
            rb_review_request_set_status( $rid, $status );
            print "Status changed to: $opt_status\n";
            exit;
        }
    }

    # The edit options are --update-diff and --update-all. The default should be --update-all.
    unless ($opt->{'update-diff'}) {
        $opt->{'update-all'} = 1;
    }

    my $changed = 0;
    my %cset = p4_cset_get( $rr{'changenum'} );

    if ( $opt->{'target-groups'} ) {
        my $opt_gropus = $opt->{'target-groups'};
        rb_review_request_draft_set_field( $rid, 'target_groups',
            $opt_groups );
        $rr{'target_groups'} = $opt_groups;
        $changed = 1;
    }
    if ( $opt->{'target-people'} ) {
        my $opt_people = $opt->{'target-people'};
        rb_review_request_draft_set_field( $rid, 'target_people',
            $opt_people );
        $rr{'target_people'} = $opt_people;
        $changed = 1;
    }

    if ( $opt->{'update-all'} ) {
        my $description = join( "\n", @{ $cset{'Description'} } );
        rb_review_request_draft_set_field( $rid, 'description',
            $description );
        $rr{'description'} = join( '\n', @{ $cset{'Description'} } );

        my $summary = ${ $cset{'Description'} }[0];
        rb_review_request_draft_set_field( $rid, 'summary', $summary );
        $rr{'summary'} = ${ $cset{'Description'} }[0];

        my @jobs;
        foreach ( @{ $cset{'Jobs'} } ) {
            m/^\s*(\S+)/;
            push( @jobs, $1 );
        }
        my $bugs = join( ',', @jobs );
        rb_review_request_draft_set_field( $rid, 'bugs_closed', $bugs );
        $rr{'bugs_closed'} = $bugs;
        $changed = 1;
    }

    if ( $opt->{'update-all'} or $opt->{'update-diff'} or $opt->{'shelve'} ) {
        my %p4info       = p4_info();

        # If this is a new review, the diff has already been uploaded, but if this
        # is an update of an existing review, we need to upload the diff now.
        unless ($new_review) {
            my @diff_lines   = p4_diff_cset( $rr{'changenum'} );
            my $diff_content = '';
            foreach (@diff_lines) {
                $diff_content .= $_;
            }
            if ( !$diff_content ) {
                die("Diff is empty.\n");
            }
            rb_upload_diff( $rid, $p4info{'Server address'}, $diff_content );
        }
        if ( $opt->{'shelve'} ) {
            p4_update_shelve( $rid, $rr{'changenum'} );
            rb_review_request_add_shelve_comment( $rid, $rr{'changenum'} );
        }
        $changed = 1;
    }

    if ($changed) {
        my $review_url = rb_uri("r/$rid/");
        if ( $opt->{'publish'} ) {
            rb_review_request_publish($rid);
            print "Review request $rid published ($review_url)\n";
            print "Changelist: $changenum\n";
        }
        else {
            print "Review request $rid is ready ($review_url).\n";
            print "Changelist: $changenum\n";
            print "Be sure to publish when finished.\n";
        }
    }
}

sub do_rr_submit {
    my ( $changenum, $opt ) = @_;

    unless ($changenum) {
        die "Need the changelist number for this review.\n";
    }

    my $rid = rb_get_review_id_from_changelist($changenum);
    unless ($rid) {
        die "Can't find an open review for change list: $changenum\n";
    }

    my %data    = rb_review_request_get($rid);
    my %rr      = %{ $data{'review_request'} };
    my $cset_id = $rr{'changenum'};
    if ( !$cset_id ) {
        die("Cannot find changeset in review request.\n");
    }
    if ( $rr{'status'} ne 'pending' ) {
        die("Review request is not pending\n");
    }

    my %cset = p4_cset_get($cset_id);
    if ( $cset{'Status'} ne 'pending' ) {
        unless ( $opt->{'force'} ) {
            die("Changeset is not pending\n");
        }
    }

    if ( $cset{'Status'} eq 'pending' ) {
        my @reviewers = rb_review_request_review_get_ship_its($rid);
        if (@reviewers) {
            p4_cset_set_meta( %cset, 'Reviewed by',
                join( ', ', @reviewers ) );
        }
        else {
            unless ( $opt->{'force'} ) {
                die("No reviews marked Ship It. You may use --force to submit anyway.\n"
                );
            }
        }

        p4_cset_set_meta( %cset, 'Reviewboard', $rid );
        p4_cset_put(%cset);
        if ( p4_change_is_shelved($cset_id) ) {
            if ( $opt->{'force'} ) {
                p4_delete_shelve($cset_id);
            }
            else {
                die "Error: Cannot submit a shelved change ($cset_id).\n"
                    . "       You may use --force to delete the shelved change\n"
                    . "       automatically prior to submit.\n";
            }
        }
        my $submitted_change = p4_submit_cset( $cset_id, $opt->{'edit'} );

        if ( defined $submitted_change ) {
            rb_review_request_set_changelist( $rid, $submitted_change );
            print "Change $submitted_change submitted.\n";
        }
    }

    rb_review_request_set_status( $rid, 'submitted' );
    print "Review $rid closed.\n";
}

sub do_diff {
    my ( $changenum, $opt ) = @_;
    my @diff_lines;
    if ($changenum) {
        @diff_lines = p4_diff_cset($changenum);
    }
    else {
        @diff_lines = p4_diff_opened();
    }
    foreach (@diff_lines) {
        print $_;
    }
}

sub parse_server {
    my $opt = shift;

    # rb users will just pass the server name, but people using post or post-review
    # will pass the entire url. We should handle both.
    my $url = $opt->{'server'};
    my ($server, $ssl);

    # if we have a server, parse it and return. If not, undef will be returned
    # and ignored.
    if ($url) {
        if (substr($url, 0, 4) eq 'http') {
            if (substr($url, 0, 5) eq 'https') {
                $server = substr($url, 8);
                $ssl = 1;
            }
            else {
                $server = substr($url, 7);
                $ssl = 0;
            }
        }
        else {
            $server = $url;
            $ssl = $opt->{'ssl'};
        }
    }
    return ($server, $ssl);
}

####
#### Usage and Help
####
sub usage {
    use File::Basename;
    my $prog = basename $0;

    print <<EOH;
Usage: $prog [OPTIONS] create|edit|submit [changenum]

Create, edit and submit review requests. 

This script is a light version of the old rb script,updated to work with the
new Review Board Web API. The functionality has been distilled to the common
workflow of creating, editing and submitting reviews.

Deprecation Warning:

This script is deprecated and will have limited support. If you're on a shared
development system or a system with Python 2.5 or greater, it is highly
recommended you use either post, or post-review. If you're on Windows, only
post-review is supported.

For more information, see:

/build/cm/bin/post --help

http://www.reviewboard.org/docs/manual/1.6/users/tools/post-review/#post-review


Commands:
  create [changenum]    Create from default change or specified change list.
    edit  changenum     Edit the review associated with specified change list.
  submit  changenum     Submit the review associated with specified change list.
    diff [changenum]    Print diff to STDOUT. If no changenum, default change is used.

Options:
  -h, --help            show this help message and exit
  -v [-v -v],           Increase verbosity level with each 'v'.
  --server=<host>       Use specified server. Default is the 'server' entry in
                        your \$HOME/.rbrc file.  You will be prompted for login 
                        if necessary and the server name will be saved.
  --ssl                 When specifying a server, use this option if https is required.

  Create and Edit Options:
    -p, --publish       Publish the review.
    --target-groups=<group [,groups]>
                        Assign or replace ReviewBoard groups for this review.
    --target-people=<user [,users]>
                        Assign or replace reviewers for this review.
    --shelve            Create or update p4 shelve for the files in the
                        review.
    --update-diff       Uploads a new diff, but does not update information
                        from change list.
    --update-all        Updates diff and all information in change list.

  Submit Options:
    -f, --force         Submit even if the review doesn't meet all
                        requirements.
    -e, --edit-changelist
                        Edit the change list before submitting.



EOH

    exit();
}

########################################
### Main
########################################
my $opt = {};
GetOptions(
    $opt,                 # Hash to hold options
    'debug',              # Print debug information
    'verbose+',           # Increate verbosity level
    'server=s',           # Specify server name
    'ssl',                # Use https
    'publish',            # publish the review
    'target-groups=s',    # Assign review to list of groups
    'target-people=s',    # Assign review to list of users
    'shelve',             # Shelve the files
    'update-diff',        # Update the diff only
    'update-all',         # Update diff and info in change list
    'force',              # Force the submit
    'edit',               # Edit the change before submit
    'help',
) or usage();

if ( $opt->{'help'} or not @ARGV ) {
    usage();
}

# Set the legacy verbose_level
if ( $opt->{'verbose'} ) {
    $verbose_level += $opt->{'verbose'};
}

my $cmd = shift @ARGV;
if ( $cmd eq 'rr' or $cmd eq 'reviewrequest' ) {
    print "Use of 'rr' or 'reviewrequest' is no longer required.\n";
    $cmd = shift @ARGV;
}

my %actions = (
    'create' => \&do_rr_create,
    'new'    => \&do_rr_create,
    'edit'   => \&do_rr_edit,
    'update' => \&do_rr_edit,
    'submit' => \&do_rr_submit,
    'diff'   => \&do_diff,
    'help'   => \&usage,
);

unless ($cmd) {
    die "Need a command - either create, edit or submit. Try -h for usage.\n";
}
unless ( defined $actions{$cmd} ) {
    die "Unrecognized command: $cmd\n";
}

if ( $opt->{'debug'} ) {
    $DEBUG = 1;
}

# Look for a possible change list number. We'll let the subroutines sanity check it.
my $changenum;
if (@ARGV) {
    $changenum = shift @ARGV;
}

# A user P4DIFF could interfere with our diff
delete $ENV{'P4DIFF'};

# Process preferences
prefs_load();
my ($server, $ssl) = parse_server($opt);
if (defined $server) {
    $prefs{'server'} = $server;
    prefs_save();
}
if (defined $ssl) {
    $prefs{'ssl'} = $ssl;
    prefs_save();
}
p4_config_load();

# Set up user agent
$ua->cookie_jar(
    HTTP::Cookies->new(
        file         => $prefs{'cookiefile'},
        hide_cookie2 => 1,
        autosave     => 1
    )
);
$ua->timeout( $prefs{'timeout'} );

# Call command and we're done.
$actions{$cmd}->( $changenum, $opt );
exit;

__END__

